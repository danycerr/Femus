// ===============================================================
// --------------   NAVIER-STOKES system [NS_F] ------------------
// ===============================================================
#include "Equations_conf.h"
#define NNL_ITER (0)
#ifdef FSI_EQUATIONS
// ==============================================================
// FSI_EQUATIONS==0 projection solver (u,v,w) ( P in NSP_EQUATIONS)
// FSI_EQUATIONS==1 coupled    solver (u,v,w,p)
// FSI_EQUATIONS==2 segregated solver (u,v,w) ( P in NSP_EQUATIONS)
// ===============================================================

// class files --------------------------------------------------
#include "MGSclass_conf.h"        // Navier-Stokes class conf file
#include "MGSolverFSI.h"       // Navier-Stokes class header file


// config file -------------------------------------------------
#include "MGFE_conf.h"        // FEM approximation
#include "MGGeomEl.h"        // FEM approximation
#include "Printinfo_conf.h"  // Print options

// local Femus class include -----------------------------------
// #include "MGMesh.h"          // Mesh class
#include "MeshExtended.h"
#include "MGFE.h"          // Mesh class
#include "MGSystem.h"        // System class
#include "MGEquationsSystem.h"  // Equation map class
#include "EquationSystemsExtendedM.h"  // Equation map class

// standard lib -----------------------------------------------
#include <string.h>          // string library

// local alg lib -----------------------------------------------
#include "dense_matrixM.h"   // algebra dense matrices
#include "sparse_matrixM.h"  // algebra sparse matrices
#include "dense_vectorM.h"   // algebra dense vectors
#include "numeric_vectorM.h" // algebra numerical vectors
#include "linear_solverM.h"  // algebra solvers
// ==============================================================
#ifdef HAVE_MED
#include "MEDCouplingUMesh.hxx"
#include "MEDCouplingFieldDouble.hxx"
#include "MEDLoader.hxx"
#include "InterfaceFunctionM.h"
#endif
#include "vof_config.h"
// ==================================================================
/// This routine constructs the FSI class:
MGSolFSI::MGSolFSI(
  MGEquationsSystem& mg_equations_map_in,
  int             nvars_in[],
  std::string     eqname_in,
  std::string     varname_in
):  MGSolDA(mg_equations_map_in,nvars_in,eqname_in,varname_in),
  /// A) reading parameters
  _offset(_mgmesh._NoNodes[_NoLevels-1]), // mesh nodes (top level)
  _dt(_mgutils.get_par("dt")),       // parameter  dt
  _uref(mg_equations_map_in.get_par("Uref")),    // parameter  u reference
  _lref(mg_equations_map_in.get_par("Lref")),    // parameter  l reference
  _rhof(mg_equations_map_in.get_par("rho0")),    // parameter density
  _muf(mg_equations_map_in.get_par("mu0")),
  _rhos(mg_equations_map_in.get_par("rhos")),    // parameter density
  _ni(mg_equations_map_in.get_par("nis")),
  _Emod(mg_equations_map_in.get_par("Es")),
  _hs(mg_equations_map_in.get_par("hs"))
{
  // parameter viscosity
  // ================================================================

  /// B) setting class variables
  // class variable namesj
  _dir=0;
#if FSI_EQUATIONS==2       //   segregated ( P in NSP_EQUATIONS)
  if(!varname_in.compare("u")) _dir=0;   // u-equationFSIAP
  if(!varname_in.compare("v")) _dir=1;   // v-equation
  if(!varname_in.compare("w")) _dir=2;   // w-equation
  _var_names[0]=varname_in;
  _refvalue[0]=_uref;
#else
  _var_names[0]="u";
  _refvalue[0]=_uref; // velocity 2D
  _var_names[1]="v";
  _refvalue[1]=_uref;
//   _refvalue[DIMENSION]=_rhof*_uref*_uref;  // pressure
#if FSI_EQUATIONS==1       //  coupled  (+P)
  _var_names[DIMENSION]="p";
  _refvalue[DIMENSION]=_rhof*_uref*_uref;  // pressure
#endif
#if DIMENSION==3
  _var_names[2]="w";
  _refvalue[2]=_uref;// velocity 3D
#endif
#endif

  /// C ) setting solver type
  for(int l=0; l<_NoLevels; l++)  _solver[l]->set_solver_type(SOLVER_FSI);



  _dirg[0] = mg_equations_map_in.get_par("dirgx");    // x-gravity
  _dirg[1] = mg_equations_map_in.get_par("dirgy");    // y-gravity
  _dirg[2] = mg_equations_map_in.get_par("dirgz");    // z-gravity

//     std::cout << " Reynolds " << _IRe << " mus " <<  _mus << "\n";
  /// D) setting nondimensional parameters
  _IRe=_muf/(_rhof*_lref*_uref);          // Reynolds number
  _IFr=9.81*_lref/(_uref*_uref);          // Froud number
  _lambda=(_ni*_Emod)/(_rhos*(1+_ni)*(1-2*_ni));//.001;
  _mus=_Emod/(_rhos*2*(1+_ni)*_lref*_uref);

  std::cout << "lambda  " << _lambda << " mus " <<  _mus << "\n";
  return;
}//  =================================================================





// ======================================================================================
/// This function assembles the matrix and the rhs.
/// There are three compiling options (in DATA/Equations_conf.h):
/// FSI_EQUATIONS==0 projection solver (u,v,w)  ( P in NSP_EQUATIONS)
/// FSI_EQUATIONS==1 coupled    solver (u,v,w,p)
/// FSI_EQUATIONS==2 segregated solver (u,v,w)  ( P in NSP_EQUATIONS)
// ======================================================================================
//  =====================================================================================
void  MGSolFSI::GenMatRhs(
  const double time,          ///< time
  const int Level,            ///< level
  const  int mode             ///< mode  (0=no rhs,1=with rhs)
)
{
  /// a) Set up
  // geometry -----------------------------------------------------------------------------------
  const int  ndim = DIMENSION;                                           //dimension
  const int  offset = _mgmesh._NoNodes[_NoLevels-1];                     // mesh nodes
  const int  el_sides= _mgmesh._GeomEl._n_sides[0];                      // element nodes
  int        el_conn[NDOF_FEM], elb_conn[NDOF_FEMB];                     // element connectivity
  int        el_neigh[NDOF_FEM];                                         // element connectivity
  int        sur_toply[NDOF_FEMB];                                       // boundary topology
  double     xx_qnds[DIMENSION*NDOF_FEM], xxb_qnds[DIMENSION*NDOF_FEMB]; // element node coords
  double    u_nl[DIMENSION*NDOF_FEM];
  double     normal[DIMENSION];
  double    mu_m;                                          // normal to the boundary

  // Gauss integration ---------------------------------------------------------------------------
  const int  el_ngauss = _fe[2]->_NoGauss1[ndim-1];                //elem gauss points
  const int  elb_ngauss = _fe[2]->_NoGauss1[DIMENSION-2];          //elem gauss points
  double det[3],JxW_g[3],InvJac[3][DIMENSION*DIMENSION];           // Jac, Jac*w Jacobean
  double dphijdx_g[3][DIMENSION];
  double dphiidx_g[3][DIMENSION]; // global derivatives at g point

  // Number of  element dof: constant[0]-linear[1]-quadratic[2] -----------------------------------
  int el_ndof[3];
  el_ndof[0]=NDOF_K;
  int elb_ndof[3];
  elb_ndof[0]=NDOF_K; // number of el dofs
  int el_mat_nrows =0;                                            // number of mat rows (dofs)
  for(int ideg=1; ideg<3; ideg++) {                               //     ...
    el_ndof[ideg]=((_nvars[ideg]>0)? _fe[ideg]->_NoShape[ndim-1]:0);                    //   computing
    elb_ndof[ideg]=((_nvars[ideg]>0)?_fe[ideg]->_NoShape[ndim-2]:0);                  //     ...
    el_mat_nrows +=_nvars[ideg]*el_ndof[ideg];
  };
  el_mat_nrows +=  el_ndof[0]*_nvars[0];

#if FSI_EQUATION%2==0
  int  el_ndofp=_fe[1]->_NoShape[ndim-1];
#endif

  int el_mat_ncols = el_mat_nrows;                                //square matrix
  std::vector<int> el_dof_indices(el_mat_ncols);                  // element dof vector

  // fields -> Navier-Stokes ----------------------------------------------------------------------


  int ns_idx=_data_eq[2].indx_ub[_data_eq[2].tab_eqs[FS_F]];      // FSI equation [FS_F]]
  int sdx_idx=_data_eq[2].indx_ub[_data_eq[2].tab_eqs[SDSX_F]];      // DS equation [SDSX_F]]
  int t_idx=_data_eq[2].indx_ub[_data_eq[2].tab_eqs[T_F]];      // DS equation [SDSX_F]]
  double vel_g[DIMENSION];
  double u_old[DIMENSION*NDOF_FEM];
  double u_oold[DIMENSION*NDOF_FEM];
  double p_proj[DIMENSION*NDOF_FEM];
  double dp_proj[DIMENSION*NDOF_FEM];
  double vel_gdx[DIMENSION*DIMENSION];   // velocity field
  double kappa_mg[2];
  double u_nlg[DIMENSION];
  double ds_old[DIMENSION*NDOF_FEM];
  double val_tbg[10];
  double h_eff[DIMENSION];                    // turbulence, h_eff
  double Pe_h[DIMENSION];
  double f_upwind[DIMENSION];             // local Peclet, upwind
  double src_value[DIMENSION];
  double bc_value[DIMENSION];
  int iaxisim=0;// axysimmetry
  double damping=0.5;
  double src_value2[1];
#ifdef  AXISYM
  iaxisim=1; // axysimmetry
#endif

#if FSI_EQUATIONS==1
  double penalty_f2=0.e+0;
  double penalty_s2=0.e+0;
  double impl_pen_s=0.e+0;//implict term of penalty method solid
  double impl_pen_f=0.e+0;//implict term of penalty method fluid

#else
  double proj_s=1.e+0;
  double proj_f=1.e+0;
//     if (time<200*_dt) proj_f=2.e-1;
//     if (time<100*_dt) proj_f=1.e-1;
  double penalty_f2=0.e+0;
  double penalty_s2=0.e+0;
//   double impl_pen_s=_dt;//implict term of penalty method solid
//   double impl_pen_f=_dt;//implict term of penalty method fluid
  double impl_pen_s=1.;//implict term of penalty method solid
  double impl_pen_f=1.;//implict term of penalty method fluid
#endif
  double val_matp[27*DIMENSION];
  int imesh=atoi(_mgutils.get_file("MESHNUMBER").c_str());


#ifdef  HAVE_MED
  EquationSystemsExtendedM *ext_es=dynamic_cast<EquationSystemsExtendedM *>(&_mgeqnmap);
  int interface_id2=3;
  InterfaceFunctionM * source2= ext_es->get_interface_fun(interface_id2);
  int * map_mg2 ;
  int * map_med2;
  int n_map2;
  map_mg2  = source2->get_map_mg();
  map_med2 = source2->get_map_med();
  n_map2 = source2->get_n();


#endif

  // element matrix and rhs  (mode 0= matrix only or mode 1=matrix +rhs) --------------------------
  A[Level]->zero();  if(mode ==1) b[Level]->zero();                 // global matrix+rhs
  DenseMatrixM KeM;  DenseVectorM FeM;                              // local  matrix+rhs
  KeM.resize(el_mat_nrows,el_mat_ncols);  FeM.resize(el_mat_nrows); // resize  local  matrix+rhs

  // Computing the number of dofs to level Level in each processor (ndof_lev)
  int ndof_lev=0;
  for(int pr=0; pr <_mgmesh._iproc; pr++) {// delta dofs in each level
    int delta =_mgmesh._off_el[0][pr*_NoLevels+Level+1]-_mgmesh._off_el[0][pr*_NoLevels+Level];
    ndof_lev +=delta;
  }

  /// b) Element  Loop over the volume (n_elem)
  const int nel_e = _mgmesh._off_el[0][Level+_NoLevels*_iproc+1]; // start element
  const int nel_b = _mgmesh._off_el[0][Level+_NoLevels*_iproc];   // stop element
  for(int iel=0; iel < (nel_e - nel_b); iel++) {

    // set to zero matrix and rhs and center
    KeM.zero();   FeM.zero();

    // geometry and element  fields -----------------------------------------------------
    // Element (iel) Connectivity (el_conn)  and coordinates (xx_qnds) at level Level
    _mgmesh.get_el_nod_conn(0,Level,iel,el_conn,xx_qnds);
    _mgmesh.get_el_neighbor(el_sides,0,Level,iel,el_neigh);

    // set element-nodes variables  bc (bc_q_dofs)
    get_el_dof_bc(Level,iel+ndof_lev,_el_dof,el_conn,offset,el_dof_indices,_bc_vol,_bc_bd);

    double cc=0.;  double cc2=0.;

    // element nodes coordinates
    for(int idim=0; idim<DIMENSION; idim++) {
      for(int d=0; d< NDOF_FEM; d++)  _data_eq[2].ub[idim*NDOF_FEM+d]=xx_qnds[idim*NDOF_FEM+d];
      // element grid distance
      h_eff[idim]=fabs(xx_qnds[idim*NDOF_FEM+2+4*(DIMENSION-2)]-xx_qnds[idim*NDOF_FEM+0]);
      double h_1=fabs(xx_qnds[idim*NDOF_FEM+3+4*(DIMENSION-2)]-xx_qnds[idim*NDOF_FEM+1]);
      if(h_eff[idim] <  h_1) h_eff[idim]=h_1;  // Max dx diagonal term
    }
    // external fields (from constant 0 to quadratic 2)
    for(int deg=0; deg<3; deg++) {
      for(int eq=0; eq<_data_eq[deg].n_eqs; eq++) {
        _data_eq[deg].mg_eqs[eq]->get_el_sol(0,_data_eq[deg].indx_ub[eq+1]-
                                             _data_eq[deg].indx_ub[eq],el_ndof[deg],el_conn,offset,_data_eq[deg].indx_ub[eq],
                                             _data_eq[deg].ub);
      }
    }
    ////-----------------------------------------------------------------------------------------------------------------------------------------------------
#if FSI_EQUATIONS==0 // pressure as external field (projection)//    
    _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F]]->get_el_nonl_sol(0,DIMENSION,el_ndof[2],el_conn, offset,0,u_nl);
    _data_eq[1].mg_eqs[_data_eq[1].tab_eqs[P_F]]->get_el_sol(0,1,el_ndofp,el_conn, offset,0,_data_eq[1].ub);
    _data_eq[1].mg_eqs[_data_eq[1].tab_eqs[P_F]]->get_el_oldsol(0,1,el_ndofp,el_conn, offset,1,_data_eq[1].ub);

    _data_eq[1].mg_eqs[_data_eq[1].tab_eqs[P_F]]->get_el_sol(0,1,el_ndofp,el_conn, offset,0,p_proj);
    _data_eq[1].mg_eqs[_data_eq[1].tab_eqs[P_F]]->get_el_oldsol(0,1,el_ndofp,el_conn, offset,0,dp_proj);

    _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F]]->get_el_sol(0,DIMENSION,el_ndof[2],el_conn, offset,0,u_old);
    _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F]]->get_el_oldsol(0,DIMENSION,el_ndof[2],el_conn, offset,0,u_oold);
    for(int kdim=0; kdim<ndim; kdim++) {
      _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[SDSX_F+kdim]]->
      get_el_sol(0,1,el_ndof[2],el_conn, offset,kdim,ds_old);
    }
    std::cout << " print p  "<<std::endl ;
    for (int itmp=0; itmp<el_ndofp; itmp++) std::cout << "   "<< p_proj[itmp]/dp_proj[itmp];
    std::cout << std::endl;
#endif
#if FSI_EQUATIONS==1 //   coupled
    _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F]]->get_el_sol(DIMENSION,1,el_ndof[1],el_conn, offset,0,_data_eq[1].ub);
//     _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[NS_F]]->get_el_sol(DIMENSION,1,el_ndof[1],el_conn, offset,0,_data_eq[1].ub);
    _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F]]->get_el_sol(0,DIMENSION,el_ndof[2],el_conn, offset,0,u_old);
    _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F]]->get_el_nonl_sol(0,DIMENSION,el_ndof[2],el_conn, offset,0,u_nl);
    for(int kdim=0; kdim<ndim; kdim++) {
      _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[SDSX_F+kdim]]->
      get_el_sol(0,1,el_ndof[2],el_conn, offset,kdim,ds_old);
    }

    int deg=2;
    for (int eq=0; eq<_data_eq[deg].n_eqs; eq++) {
      _data_eq[deg].mg_eqs[eq]->get_el_sol(0,_data_eq[deg].indx_ub[eq+1]-
                                           _data_eq[deg].indx_ub[eq],el_ndof[deg],el_conn,offset,_data_eq[deg].indx_ub[eq],
                                           _data_eq[deg].ub);
    }
#endif
#if FSI_EQUATIONS==2 // pressure as external field (splitting)
    for(int kdim=0; kdim<ndim; kdim++) {
      _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F+kdim]]->
      get_el_nonl_sol(0,1,el_ndof[2],el_conn,offset,kdim,u_nl);
      _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F+kdim]]->
      get_el_sol(0,1,el_ndof[2],el_conn, offset,kdim,u_old);
      _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[SDSX_F+kdim]]->
      get_el_sol(0,1,el_ndof[2],el_conn, offset,kdim,ds_old);
      _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F+kdim]]->
      get_el_oldsol(0,1,el_ndof[2],el_conn, offset,kdim,u_oold);
    }
//     _data_eq[1].mg_eqs[_data_eq[1].tab_eqs[P_F]]->get_el_sol(0,1,el_ndofp,el_conn, offset,0,_data_eq[1].ub);
//     _data_eq[1].mg_eqs[_data_eq[1].tab_eqs[P_F]]->get_el_oldsol(0,1,el_ndofp,el_conn, offset,1,_data_eq[1].ub);

    _data_eq[1].mg_eqs[_data_eq[1].tab_eqs[P_F]]->get_el_sol(0,1,el_ndofp,el_conn, offset,0,p_proj);
    _data_eq[1].mg_eqs[_data_eq[1].tab_eqs[P_F]]->get_el_oldsol(0,1,el_ndofp,el_conn, offset,0,dp_proj);

#endif
    ////-----------------------------------------------------------------------------------------------------------------------------------------------------
    _mgmesh.get_el_nod_disp(0,Level,iel/*,el_conn*/,_disp_el);// _disp_el is the last displacement of the element

// // // //     VOF
    double xm[3];
    xm[2]=0.;
    for (int idim=0; idim<DIMENSION; idim++) xm[idim]=0.;
    for (int idim=0; idim<DIMENSION; idim++) {
      for (int d=0; d< NDOF_FEM; d++) xm[idim] += xx_qnds[idim*NDOF_FEM+d]/NDOF_FEM;
    }
    double  hx[3];
    hx[2]=0;
    int ixyz[3];
    ixyz[2]=0;
    int nx[3]= {NX,NY,NZ};
    for (int idim=0; idim<ndim; idim++) {
//            nx[idim]=16;
      hx[idim] = 1./nx[idim];
      ixyz[idim]=(int)((xm[idim]-0.25*hx[idim])*nx[idim]);
    }

    cc=0; cc2=0;
    int count=0;
    for (int iz=0; iz<ndim-1; iz++) {
      for (int ix=0; ix<2; ix++) {
        for (int iy=0; iy<2; iy++) {
          int indx = ixyz[0]+ix+( nx[0]+1)*(ixyz[1]+iy)+( nx[0]+1)*( nx[1]+1)*(ixyz[2]+iz);
          source2->eval(indx, 1, src_value2);
          cc2 += src_value2[0];
          count++;
        }
      }
    }
// // //         END VOF



    // element fields ----------------------------------
    double phase=1.;
    double rho =  phase;
    phase=(_bc_vol[NDOF_FEM-1]<1.5)?0:1;


    kappa_mg[0] =0;    kappa_mg[1] =0;    mu_m =0.;
    for(int i=0 ; i<ndim; i++) src_value[i]=0.;

    if(phase==0   ) {
      double vof_phase= cc2/4;
      double vof_phase2= 0.;
//       rho =(1- vof_phase2)*( 100*vof_phase+(1-vof_phase))+vof_phase2*1.;
      rho = 1*vof_phase*1+(1-vof_phase)*1;
      double mu= 1*vof_phase+(1-vof_phase)*1;
//           rho=1;mu=1;
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      for(int jvar=0; jvar<DIMENSION; jvar++)  for(int j=0; j<el_ndof[2]; j++) val_matp[j+jvar*el_ndof[2]]=0;

/// c) gaussian integration loop (n_gauss)
      double sum=0.; double sum2=0.;
#if FSI_EQUATIONS%2==0
      for(int qp=0; qp<  el_ngauss; qp++) {

        // shape functions at gaussian points --------------------------------------------------------------
        // quadratic continuous
        det[2]      = _fe[2]->Jac(qp,xx_qnds,InvJac[2]);     // Jacobian
        JxW_g[2] =det[2]*_fe[2]->_weight1[ndim-1][qp];       // weight
        _fe[2]->get_phi_gl_g(ndim,qp,_phi_g[2]);
        _fe[2]->get_dphi_gl_g(ndim,qp,InvJac[2],_dphi_g[2]); // global coord deriv

        det[1]      = _fe[1]->Jac(qp,xx_qnds,InvJac[1]);     // Jacobian
        _fe[1]->get_phi_gl_g(ndim,qp,_phi_g[1]);
        _fe[1]->get_dphi_gl_g(ndim,qp,InvJac[1],_dphi_g[1]); // global coord deriv
        // Assemblying Matrix quad ---------------------------------

        for(int jvar=0; jvar<DIMENSION; jvar++) {
          for(int j=0; j<el_ndof[2]; j++) {
            double vv=JxW_g[2]/**_bc_vol[j+jvar*NDOF_FEM]*/*_dphi_g[2][j+jvar*el_ndof[2]];
            sum += vv*u_oold[j+jvar*NDOF_FEM];
          }
        }


      }
#endif
      /// c) gaussian integration loop (n_gauss)
      for(int qp=0; qp<  el_ngauss; qp++) {
        // shape functions at gaussian points --------------------------------------------------------------
        // quadratic continuous
        det[2]      = _fe[2]->Jac(qp,xx_qnds,InvJac[2]);     // Jacobian
        JxW_g[2] =det[2]*_fe[2]->_weight1[ndim-1][qp];       // weight
        _fe[2]->get_phi_gl_g(ndim,qp,_phi_g[2]);
        _fe[2]->get_dphi_gl_g(ndim,qp,InvJac[2],_dphi_g[2]); // global coord deriv
        // discontinuous and continuous linear
        for(int ideg=0; ideg<2; ideg++) if(_nvars[ideg]>0) _fe[ideg]->get_phi_gl_g(ndim,qp,_phi_g[ideg]);    // shape funct
        _fe[1]->get_phi_gl_g(ndim,qp,_phi_g[1]);  // shape funct
        // linear and quadratic fields ---------------------------------------------------------------------
        // linear fields -> pressure
        // ------------------------------------------------------------------------------------------------------------
#if (FSI_EQUATIONS%2==0)  // projection and segregated
        interp_el_sol(_data_eq[1].ub,0,2,_phi_g[1],el_ndofp,_ub_g[1]);
// #else                   // coupled
// //       interp_el_sol(_data_eq[1].ub,0,1,_phi_g[1],el_ndof[1],_ub_g[1]);
// //       _ub_g[1][1]=0.;
#endif
        // -----------------------------------------------------------------------------------------------------------
        // quadratic fields
        interp_el_sol(_data_eq[2].ub,0,_data_eq[2].indx_ub[_data_eq[2].n_eqs],_phi_g[2],el_ndof[2],_ub_g[2]);                                // field
//         interp_el_gdx(u_oold,0,DIMENSION,_dphi_g[2],el_ndof[2],vel_gdx); // derivatives

#ifdef AXISYM
        JxW_g[2]  *=_ub_g[2][0];  JxW_g[1]  *=_ub_g[2][0];
#endif
        _IRe=_muf*mu/(_rhof*_lref*_uref);

        double IRe_eff=_IRe;

        // velocity[NS_F] -> (quad,_indx_eqs[NS_F+idim]) ---------------------------------------------------
        double mod2_vel=1.e-20;
        _sP=1.e-20;

        for(int idim=0; idim< DIMENSION; idim++) {
          // velocity field  -> gaussian points <- _ub_g[2][ns_idx+idim]
          u_nlg[idim]=0.; vel_g[idim]=0.;
          for(int k=0; k< NDOF_FEM; k++) {
            u_nlg[idim] += u_nl[k+idim*NDOF_FEM]*_phi_g[2][k];

            vel_g[idim] += u_old[k+idim*NDOF_FEM]*_phi_g[2][k];
            vel_g[idim]=  u_nlg[idim];
          }
          mod2_vel += u_nlg[idim]*u_nlg[idim];

        }
        mod2_vel =sqrt(mod2_vel);
        // upwind term -> f_upwind
        for(int idim=0; idim< DIMENSION; idim++) {
          Pe_h[idim]=0.5*mod2_vel*h_eff[idim]/_IRe;             // local  Peclet
          f_upwind[idim]=UP_WIND_FSI*0.25*(1./tanh(Pe_h[idim])-1./Pe_h[idim])*h_eff[idim]/mod2_vel;
        }
        // -------------------- Temperature[T_F] -> (quad,_indx_eqs[T_F]) -------------------------------------
#ifdef T_EQUATIONS
// #ifdef TEMP_CONST
        double Temp_g=_ub_g[2][t_idx];
//       std::cout<<Temp_g<<std::endl;
//       rho *= _mgphys.adensity(Temp_g);
//       mu *= _mgphys.aviscosity(Temp_g);
// #endif
#endif
        // ----------------- Turbulent viscosity [K_F] -> (quad,_indx_eqs[K_F]) ---------------------------
        _mu_turb=0.;// eff visc turb at g pt
#ifdef TBK_EQUATIONS
        const int k_idx=_data_eq[2].indx_ub[_data_eq[2].tab_eqs[K_F]];  // kappa-equations
        _kappa_g[0]= _ub_g[2][k_idx];
        _kappa_g[1]= _ub_g[2][k_idx+1];
        f_mu(val_tbg);
        kappa_mg[0] +=_kappa_g[0];
        kappa_mg[1] +=_kappa_g[1];
#endif
        IRe_eff = _IRe*(1.+_mu_turb);//  visc_eff  at g pt
//        mu_m +=IRe_eff;
        // ---------------------------------------------------------------------------------------------------


        /// d) Assemblying NS equation
        for(int i=0; i< el_ndof[2]; i++) {  // +++++++++++
          // set up row i
          for(int  idim=0; idim<ndim; idim++)  dphiidx_g[2][idim]=_dphi_g[2][i+idim*el_ndof[2]];
          const double phii_g=_phi_g[2][i];
          // loop u,v,w
          for(int  ivar=0; ivar< _nvars[2]; ivar++)    {
            int    indx=i+ivar*el_ndof[2]; // ivar=0;
            double dtxJxW_g=JxW_g[2]*(_bc_vol[i+ivar*NDOF_FEM]%2)*rho;

            // Assemblying rhs ----------------------------
// 	    if(vof_phase>0.0001){std::cout<<"heyyyy I' m the bubble"<<std::endl;}
            if(mode == 1)                {
              FeM(indx)  +=  dtxJxW_g*(
                               vel_g[ivar+_dir]*phii_g/_dt //* rho   // time
                               + vof_phase*20*_IFr*_dirg[ivar+_dir]*phii_g// x-gravity
//                                 +((ivar==2)? -1:0)
                               -1.*(sum)*dphiidx_g[2][ivar+_dir]*penalty_f2
                             );
            }
// std::cout<<"       "<<vel_g[ivar+_dir]<<std::endl;
            // ---------------------------------------------------------
            for(int j=0; j<el_ndof[2]; j++) {
              const double phij_g= _phi_g[2][j];
              // set up
              double Lap_g=0.,Adv_g=0., Div_g= 0;
#ifdef  AXISYM
              Lap_g =(1-ivar)*IRe_eff*
                     phii_g*phij_g/(_ub_g[2][0]*_ub_g[2][0]);// axysimmetry
#endif
              for(int kdim=0; kdim<ndim; kdim++) {
                dphijdx_g[2][kdim] =_dphi_g[2][j+kdim*el_ndof[2]];
                Adv_g +=u_nlg[kdim]/*vel_g[kdim]*/*dphijdx_g[2][kdim]*phii_g;
//                 Adv_g +=vel_g[kdim]*dphijdx_g[2][kdim]*phii_g;
                Lap_g +=(IRe_eff+f_upwind[kdim]* u_nlg[kdim]* u_nlg[kdim])*(dphijdx_g[2][kdim]*dphiidx_g[2][kdim]
                                                                           );
                Div_g +=vel_gdx[kdim+kdim*ndim];
              }
              // diagonal blocks [1-5-9]
#if FSI_EQUATIONS%2==0
              if(j<el_ndofp) FeM(indx)+= dtxJxW_g*(p_proj[j]+1.*dp_proj[j])* _phi_g[1][j]*dphiidx_g[2][ivar+_dir]*proj_f;
#endif


//             for(int jvar=0; jvar<ndim; jvar++)  FeM(indx)+= 0.001*dtxJxW_g*(u_oold[j+jvar*el_ndof[2]])*dphijdx_g[2][jvar+_dir]*dphiidx_g[2][ivar+_dir];
              KeM(indx,j+ivar*el_ndof[2]) +=dtxJxW_g*/*rho**/(
                                              phij_g*phii_g/_dt  // time
                                              + Adv_g*rho*rho            // advection
                                              + Lap_g            // viscous Laplacian
                                              + (IRe_eff+f_upwind[ivar+_dir]*u_nlg[ivar+_dir]*u_nlg[ivar+_dir])// upwind
                                              *(dphijdx_g[2][ivar+_dir]*dphiidx_g[2][ivar+_dir])   // viscous tensor
                                              + impl_pen_f*penalty_f2
                                              *dphijdx_g[2][ivar]*dphiidx_g[2][ivar+_dir]
                                              *(IRe_eff+0.*f_upwind[ivar+_dir]*u_nlg[ivar+_dir]*u_nlg[ivar+_dir])

//                                                + val_matp[j+ivar*el_ndof[2]]*dphiidx_g[2][ivar+_dir]
                                            );
              int idimp1=(ivar+1+_dir)%ndim; // block +1 [2-6-7] ---------------
#if FSI_EQUATIONS==2    // splitting 
              FeM(indx) += -1.*u_nl[j+idimp1*el_ndof[2]]*
#else       // no splitting
              KeM(indx,j+idimp1*el_ndof[2]) +=
#endif
                           dtxJxW_g* rho*(
                             (IRe_eff+f_upwind[ivar+_dir]*u_nlg[ivar+_dir]*u_nlg[idimp1])*
                             dphijdx_g[2][ivar+_dir]*dphiidx_g[2][idimp1]
                             + impl_pen_f*penalty_f2
                             *dphijdx_g[2][idimp1]*dphiidx_g[2][ivar+_dir]
                             *(IRe_eff+0.*f_upwind[ivar+_dir]*u_nlg[ivar+_dir]*u_nlg[idimp1])
//                               + val_matp[j+idimp1*el_ndof[2]]*dphiidx_g[2][ivar+_dir]
                           );
#if DIMENSION==3  // --------------------------------------------------------------------------------------
              int idimp2=(ivar+2+_dir)%ndim; // block +2 [3-4-8] ------------
#if FSI_EQUATIONS==2    // splitting         
              FeM(indx)+=  -1.*u_nl[j+idimp2*el_ndof[2]]*
#else        // no splitting
              KeM(indx,j+idimp2*el_ndof[2])+=
#endif
                           dtxJxW_g* rho*(
                             (IRe_eff+f_upwind[ivar+_dir]*u_nlg[ivar+_dir]*u_nlg[idimp2])*
                             dphijdx_g[2][ivar+_dir]*dphiidx_g[2][idimp2]
                             + impl_pen_f*penalty_f2*
                             dphijdx_g[2][idimp2]*dphiidx_g[2][ivar+_dir]
                             *(IRe_eff+0.*f_upwind[ivar+_dir]*u_nlg[ivar+_dir])

//                                            + val_matp[j+idimp2*el_ndof[2]]*dphiidx_g[2][ivar+_dir]
                           )
                           ;

#endif    // ----------------------------------------------------------------------
            } // end A element matrix quad -quad (end loop on j)---------------------------------------------

            // ------------------------------------------------------------------
#if FSI_EQUATIONS==1      // B^T element matrix ( p*div(v) )--------------------
            for(int  ikl=0; ikl<2; ikl++) {   // ikl=0 discontinuous ikl=1 continuous pressure
              for(int  ivarl=0; ivarl<_nvars[ikl]; ivarl++) {
                for(int  j=0; j<el_ndof[ikl]; j++) {
                  double psij_g=_phi_g[ikl][j];
                  KeM(indx,j+ndim*el_ndof[2]) +=dtxJxW_g*(  // MPascal
                                                  -psij_g*dphiidx_g[2][ivar]
#ifdef AXISYM
                                                  -(1-ivar)*psij_g*phii_g/_ub_g[2][0]
#endif
                                                );
                } // j
              } // ivarl
            }
#endif  // end B^T element matrix ------------------------------------
          } // end loop ivar
        } // end loop i

//------------------    QL    -----------------------------------------------------------
#if FSI_EQUATIONS==1   // only coupled Assemblying Matrix linear ------------------------
        for(int  ikl=0; ikl<2; ikl++) {   // ikl=0 discontinuous ikl=1 continuous pressure
          for(int   ivarl=0; ivarl< _nvars[ikl]; ivarl++) {
            for(int   i=0; i< el_ndof[ikl]; i++) {  // +++++++++++
              // set up row i
              int  indx=i+el_ndof[2]*_nvars[2];//ivar=0;
              const double psii_g=_phi_g[ikl][i];
//            if (mode == 1)   FeM(indx)  +=  JxW_g[2]*psii_g*_ub_g[1][0]*KOMP_FSI; //    _u_old[DIMENSION]*KOMP_FSI;

              // linear-quadratic Assemblying Matrix -----------------------------
              for(int j=0; j<el_ndof[2]; j++)     {
                const double phij_g= _phi_g[2][j];
                for(int  jvar=0; jvar< _nvars[2]; jvar++) {  // linear -quad
//                                 // p-equation
                  KeM(indx,j+jvar*el_ndof[2]) += JxW_g[2]*rho*(
                                                   psii_g*_dphi_g[2][j+jvar*el_ndof[2]]  // div=0
#ifdef AXISYM
                                                   +(1-jvar)*psii_g*phij_g/_ub_g[2][0]
#endif
                                                 );

                }// jvar
              }  // j end linear-quad --------------------------------------------

              // linear-linear Assemblying Matrix ------------------------------
              for(int j=0; j<el_ndof[1]; j++)  {
                const double psij_g=_phi_g[1][i];
                KeM(indx,j+ndim*el_ndof[2])  += JxW_g[2]*psii_g*psij_g*0.0* KOMP_FSI;
// 		if ( KeM(indx,j+ndim*el_ndof[2]) != KeM(indx,j+ndim*el_ndof[2])) std:cout<<"error pp matrix"std::endl;
              } // end linear liner -----------------------------------------------------
            }  // i
          }// ivarl end linear +++++++++++
        }
#endif  // -------------------- FSI_EQUATIONS==1 ----------------------------------------

      } // end of the quadrature point qp-loop

      kappa_mg[0] /=el_ngauss;
      kappa_mg[1] /=el_ngauss;
      mu_m /=el_ngauss;

      // ====================== end volume (element) =======================================



      // ======================================================================
      // =========================  boundary  =================================
      // ======================================================================
      for(int  iside=0; iside< el_sides; iside++) {
        if(el_neigh[iside] == -1) {

          // local matrix and rhs
//         double IRe_eff=_IRe;

          double pressure[NDOF_FEMB];
          // setup boundary element -> connectivity+coordinates
          for(int  lbnode=0; lbnode<NDOF_FEMB; lbnode++) {
            int lnode=_mgmesh._GeomEl._surf_top[lbnode+NDOF_FEMB*iside];// local nodes
            sur_toply[lbnode]=lnode;          // lbnode -> lnode
            elb_conn[lbnode]=el_conn[lnode];  // connctivity el_conn->elb_conn

            for(int idim=0; idim<ndim; idim++)   // coordinates
              xxb_qnds[idim*NDOF_FEMB+lbnode]=xx_qnds[idim*NDOF_FEM+lnode];

            pressure[lbnode]=_data_eq[1].ub[lnode];
          }

          // normal
          _fe[2]->normal_g(xxb_qnds,normal);
          // pressure flag
//         int flag_p=0;
//         for(int  k=0; k< elb_ndof[1]; k++) { flag_p += _bc_bd[sur_toply[k]+DIMENSION*NDOF_FEM];}

          for(int ivar=0; ivar< _nvars[2]; ivar++)    {

            // Dirichlet boundary conditions  ***********************
            if(_bc_vol[sur_toply[NDOF_FEMB-1]+ivar*NDOF_FEM]%2 ==0) {

//             int bc_s=(int)_bc_bd[sur_toply[NDOF_FEMB-1]+ivar*NDOF_FEM];     // b cond
              double det= _fe[2]->JacSur(elb_ngauss-1,xxb_qnds, InvJac[2]);              // jacobian
              double Ipenalty=det/_dt;                        // Dirichlet bc flag

              for(int i=0; i< elb_ndof[2]; i++) {  // +++++++++++++++++++++++

                const int  indx_sol=sur_toply[i]+(ivar+_dir)*el_ndof[2];//ivar=0;
                const int  indx_row=sur_toply[i]+(ivar)*el_ndof[2];//ivar=0;


                // bc_normal*(u \dot n)+bc_tg*(u-(u.n)n)=
                //   bc_rhs*[bc_normal*(val \dot n)+bc_tg*(val-(val.n)n)]
                int bc_s=(int)_bc_bd[indx_row]; //int bc_v=(int)_bc_vol[indx_row];
                int bc_rhs=((bc_s&4)>>2);  // (1??) nonhomogeneous
                int bc_tg=((bc_s&2)>>1);   // (?1?) tg
                int bc_normal=(bc_s%2);    // (??1) normal

                double vdotn=0.;  // non-homogeneous normal
//                 for(int kdim=0; kdim<ndim; kdim++) {
//                   const int kdof_top = _node_dof[_NoLevels-1][elb_conn[i]+kdim*offset];
//                   vel_g[kdim] =(*x_old[_NoLevels-1])(kdof_top);
//                   vdotn +=normal[kdim]*vel_g[kdim];
//                 }
                // Assemblying rhs // non-homogeneous ----------------------------
                if(mode == 1)  {
                  for(int idim=0; idim<DIMENSION; idim++) bc_value[idim]=0.;


                  FeM(indx_row) += /*bc_rhs*Ipenalty* */
                    (1-bc_rhs)*Ipenalty*(1-bc_normal)*(1-bc_tg)*0.+// bc_value[ivar]+
                    bc_rhs*Ipenalty*( // Dirichlet -> non-homogeneous flag (1??)
                      (1-bc_normal)*(1-bc_tg)*u_old[indx_sol]//_data_eq[2].ub[ns_idx*NDOF_FEM+indx_sol]// _u_old[indx_sol]    // (100) single comp bc
//                       (1-bc_normal)*(1-bc_tg)*vel_g[ivar+_dir]  //_data_eq[2].ub[ns_idx*NDOF_FEM+indx_sol]// _u_old[indx_sol]    // (100) single comp bc
//                       +bc_normal*vdotn*normal[ivar+_dir]        // (101)normal Dirichlet bc
//                       +bc_tg*(vel_g[ivar+_dir]-vdotn*normal[ivar+_dir])// (110) tg Dirichlet bc
                    );
                }

                // Assemblying Matrix ---------------------------------
                // u.n normale tg -(u.n)n
                KeM(indx_row,indx_row) +=
                  ((1-bc_normal)*(1-bc_tg)+bc_tg)*Ipenalty // (?00) single comp bc
                  +Ipenalty*normal[ivar+_dir]*normal[ivar+_dir]*(
                    bc_normal   // (?01) Normal Dirichlet bc
                    -1.*bc_tg       // (?10) tg Dirichlet bc
                  );

                for(int   jvar=ivar+_dir+1; jvar< ndim+_dir; jvar++)    {
                  int      jvar1=jvar%DIMENSION;
#if FSI_EQUATIONS==2
                  FeM(indx_row) += -1.*Ipenalty*_data_eq[2].ub[(ns_idx+jvar1)*NDOF_FEM+sur_toply[i]]*
#else
//                 if(fabs(normal[jvar1]*normal[ivar+_dir]) >1.e-13 || bc_normal >= 1){
// 		 double a= fabs(normal[jvar1]*normal[ivar+_dir]);
// 		 std::cout << a;
// 		}



                  KeM(indx_row,sur_toply[i]+jvar1*el_ndof[2]) += Ipenalty*
#endif
                                   normal[jvar1]*normal[ivar+_dir]*(
                                     +bc_normal   // (?01) Normal Dirichlet bc
                                     -bc_tg       // (?10) tg Dirichlet bc
                                   );
                }// end  +u.n normale tg -(u.n)n

              }// i loop
            } // end if  Dirichlet  ***********************************

            //  Neumann boundary conditions  ***********************************
            else if(_bc_bd[sur_toply[NDOF_FEMB-1]+ivar*NDOF_FEM] !=0) {

              double alpha_t=1.;
#ifdef TBK_EQUATIONS
              double kappa_w=kappa_mg[0]+1.e-20;
              double yplus=rho*0.547722557505*_y_dist*sqrt(kappa_w)/(_IRe);
              double u_plus=(yplus< 11.66) ? yplus:2.5*log(9.*yplus);
//              u_plus= yplus;
              alpha_t=rho*0.547722557505*sqrt(kappa_w)/u_plus;
              alpha_t=_IRe/_y_dist;
// 	    printf(" \n  yplus %f, kappa %12.10f, distance %f, alpha_t %f ",yplus,kappa_w,_y_dist,alpha_t);
// 	    std::cout << " \n  yplus "<<  yplus << " kappa " << kappa_w << " y " << _y_dist<< " alpha_t " << alpha_t;
#endif

              for(int  qp=0; qp<  elb_ngauss; qp++) {  //gaussian integration loop (n_gauss)

                // quad/linear  [2]=quad [1]=linear------------------------------------
                det[2]     = _fe[2]->JacSur(qp,xxb_qnds, InvJac[2]);   // local coord _phi_g and jac
                JxW_g[2]=det[2]*_fe[2]->_weight1[ndim-2][qp]; // weight
                _fe[2]->get_phi_gl_g(ndim-1,qp,_phi_g[2]);   // global coord _phi_g
                _fe[1]->get_phi_gl_g(ndim-1,qp,_phi_g[1]);   // global coord _phi_g


                interp_el_sol(pressure,0,1,_phi_g[1],elb_ndof[1],_ub_g[1]);

#ifdef AXISYM   // axisymmetric  (index ->0)
                interp_el_sol(_data_eq[2].ub,0,DIMENSION,_phi_g[2],elb_ndof[2],_ub_g[2]);
                JxW_g[2]  *=_ub_g[2][0];
#endif
                // ***********************************
                for(int i=0; i< elb_ndof[2]; i++) {  // Assemblying NS equation
                  // set up row i
                  const double phii_g=_phi_g[2][i];
                  const int   indx_var=sur_toply[i]+(ivar+_dir)*el_ndof[2];// volume dof index
                  const int   indx_row=sur_toply[i]+(ivar)*el_ndof[2];// volume dof index
                  // boundary flag
                  int bc_s=(int)_bc_bd[indx_row];
                  int bc_v=(int)_bc_vol[indx_row]%2;
                  double dtJxW_g=JxW_g[2]*(bc_v%2);
                  int bc_rhs   =((bc_s&4)>>2); // (1??) -> nonhomogeneous
                  int bc_tg    =((bc_s&2)>>1); // (?1?) -> tg
                  int bc_normal=(bc_s%2);      // (??1) -> normal

                  // Assemblying rhs ----------------------------
                  if(mode == 1)   {
                    if(imesh==1)
                      FeM(indx_row)  += -1.*bc_rhs*dtJxW_g*phii_g*(normal[ivar+_dir])*(_ub_g[1][0]);
                  }

// // //                                 Assemblying Matrix ---------------------------------
                  for(int j=0; j<elb_ndof[2]; j++) {  // quad -quad
                    const double phij_g= _phi_g[2][j];
                    KeM(indx_row,indx_row) +=dtJxW_g*bc_tg*alpha_t*phij_g*phii_g// (?1?) -> tg
                                             + dtJxW_g*alpha_t*normal[ivar+_dir]*normal[ivar+_dir]*phij_g*phii_g*(
                                               bc_normal // (??1) -> normal
                                               -bc_tg     // (?1?) -> tg
                                             );

                    for(int  jvar=ivar+_dir+1; jvar< ndim+_dir; jvar++)    {  // u.n normale tg -(u.n)n
                      int jvar1=jvar%DIMENSION;
#if FSI_EQUATIONS==2
                      FeM(indx_row) +=   -_data_eq[2].ub[ns_idx*NDOF_FEM+sur_toply[j]+jvar1*el_ndof[2]]*
#else
                      KeM(indx_row,sur_toply[j]+jvar1*el_ndof[2]) +=
#endif
                                         dtJxW_g*alpha_t*normal[jvar1]*normal[ivar+_dir]*phij_g*phii_g*(
                                           +bc_normal   // (?01) Normal Dirichlet bc
                                           -bc_tg       // (?10) tg Dirichlet bc
                                         );
                    }

                  }//  j-loop
                }// i-loop

              }// end gaussian  integration



            }  //  end if Neumann  ***********************************

          } // end if ivar   +++++++++++++++++++++++++++++++


        } //end if side
      } //end for iside

      // ==========================================================================
      // ====================== end fluid boundary =====================================
      // ==========================================================================
    } // // // // // if (phase==0)
// ***************************************
// // // // // // // // // solid
// **************************************

// // ==========================================================================
// // ==========================================================================
// //=======================             _ _     _ =============================
// //=======================   ___  ___ | (_) __| |=============================
// //=======================  / __|/ _ \| | |/ _` |=============================
// //=======================  \__ \ (_) | | | (_| |=============================
// //=======================  |___/\___/|_|_|\__,_|=============================
// //===========================================================================
// // ==========================================================================
// // ==========================================================================
    if(phase==1) {
      double sig_1_lin[DIMENSION]; double sig_3_lin[DIMENSION];
      for(int j=0; j < DIMENSION; j++) {sig_1_lin[j]=0; sig_3_lin[j]=0; }

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      for(int jvar=0; jvar<DIMENSION; jvar++) {
        for(int j=0; j<el_ndof[2]; j++) {val_matp[j+jvar*el_ndof[2]]  =0;}
      }
// // c) gaussian integration loop (n_gauss)
      double sum=0.; double sum2=0.;
//       rho=10;
//       _lambda=0.;
#if FSI_EQUATIONS%2==0
      for(int qp=0; qp<  el_ngauss; qp++) {

        // shape functions at gaussian points --------------------------------------------------------------
        // quadratic continuous
        det[2]      = _fe[2]->Jac(qp,xx_qnds,InvJac[2]);     // Jacobian
        JxW_g[2] =det[2]*_fe[2]->_weight1[ndim-1][qp];       // weight
        _fe[2]->get_phi_gl_g(ndim,qp,_phi_g[2]);
        _fe[2]->get_dphi_gl_g(ndim,qp,InvJac[2],_dphi_g[2]); // global coord deriv

        // Assemblying Matrix quad ---------------------------------

        for(int jvar=0; jvar<DIMENSION; jvar++) {
          for(int j=0; j<el_ndof[2]; j++) {
            double vv=JxW_g[2]/**_bc_vol[j+jvar*NDOF_FEM]*/*_dphi_g[2][j+jvar*el_ndof[2]];
            sum += vv*u_oold[j+jvar*NDOF_FEM];
          }
        }
      }
#endif
      /// c) gaussian integration loop (n_gauss)

      for(int qp=0; qp<  el_ngauss; qp++) {

        // shape functions at gaussian points --------------------------------------------------------------
        // quadratic continuous
        det[2]      = _fe[2]->Jac(qp,xx_qnds,InvJac[2]);     // Jacobian
        JxW_g[2] =det[2]*_fe[2]->_weight1[ndim-1][qp];       // weight
        _fe[2]->get_phi_gl_g(ndim,qp,_phi_g[2]);
        _fe[2]->get_dphi_gl_g(ndim,qp,InvJac[2],_dphi_g[2]); // global coord deriv

        det[1]      = _fe[1]->Jac(qp,xx_qnds,InvJac[1]); // Jacobian
        JxW_g[1] =det[1]*_fe[1]->_weight1[ndim-1][qp];        // weight
        _fe[1]->get_phi_gl_g(ndim,qp,_phi_g[1]);              // shape funct
        _fe[1]->get_dphi_gl_g(ndim,qp,InvJac[1],_dphi_g[1]);  // global coord deriv

        // discontinuous and continuous linear
        for(int ideg=0; ideg<2; ideg++)
          if(_nvars[ideg]>0)
            _fe[ideg]->get_phi_gl_g(ndim,qp,_phi_g[ideg]);  // shape funct

        // linear and quadratic fields ---------------------------------------------------------------------
        // linear fields -> pressure
        // ------------------------------------------------------------------------------------------------------------
#if (FSI_EQUATIONS%2==0)  // projection and segregated
        interp_el_sol(_data_eq[1].ub,0,2,_phi_g[1],el_ndofp,_ub_g[1]);
// #else                   // coupled
//       interp_el_sol(_data_eq[1].ub,0,1,_phi_g[1],el_ndof[1],_ub_g[1]);
//       _ub_g[1][1]=0.;
#endif
        // -----------------------------------------------------------------------------------------------------------

        // quadratic fields
        interp_el_sol(_data_eq[2].ub,0,_data_eq[2].indx_ub[_data_eq[2].n_eqs], _phi_g[2],el_ndof[2],_ub_g[2]);
        interp_el_sol(_old_sol,0,_data_eq[2].indx_ub[_data_eq[2].n_eqs], _phi_g[2],el_ndof[2],_old_solg);
//          interp_el_gdx(_data_eq[2].ub,ns_idx,DIMENSION,_dphi_g[2],el_ndof[2],vel_gdx); // derivatives
#ifdef DS_EQUATIONS
        // derivatives of the material displacement(with respect to the material coordinate)
        interp_el_gdx(_data_eq[2].ub,sdx_idx,DIMENSION,_dphi_g[2],el_ndof[2],_ub_dxg);
// // // // _ub_dxg=ux,uy,uz,vx,vy,vz
#endif

        //=====================================calculation deformation gradient==============================
// std::cout<<"J is "<<J<<std::endl;
//                           double J=Compute_J(_ub_dxg);
//                           double I=Compute_I(_ub_dxg);
#ifdef AXISYM*
        JxW_g[2]  *=_ub_g[2][0];
        JxW_g[1]  *=_ub_g[2][0];
#endif

        // Upwind -----------------------------------------------------------------------
        // velocity[NS_F] -> (quad,_indx_eqs[NS_F+idim])
        double mod2_vel=1.e-20;  _sP=1.e-20;
        for(int idim=0; idim< DIMENSION; idim++) {
          // velocity field  -> gaussian points <- _ub_g[2][ns_idx+idim]
          u_nlg[idim]=0.; vel_g[idim]=0.;
          for(int k=0; k< NDOF_FEM; k++) {
            u_nlg[idim] += u_nl[k+idim*NDOF_FEM]*_phi_g[2][k];
            vel_g[idim] += u_old[k+idim*NDOF_FEM]*_phi_g[2][k];
          }
          mod2_vel +=u_nlg[idim]*u_nlg[idim];
        }
        mod2_vel =sqrt(mod2_vel);
        // upwind term -> f_upwind
        for(int idim=0; idim< DIMENSION; idim++) {
          Pe_h[idim]=0.5*mod2_vel*h_eff[idim]/_IRe;             // local  Peclet
          f_upwind[idim]=UP_WIND_FSI*rho*0.5*(1./tanh(Pe_h[idim])-1./Pe_h[idim])*h_eff[idim]/mod2_vel;
        }
        //  Temperature[T_F] -> (quad,_indx_eqs[T_F]) -----------------------------------
#ifdef T_EQUATIONS
// #ifdef TEMP_CONST
        double Temp_g=_ub_g[2][t_idx];
        double T_ref=20;
//       std::cout<<Temp_g<<std::endl;
//       rho *= _mgphys.adensity(Temp_g);
//       mu *= _mgphys.aviscosity(Temp_g);
// #endif
#endif
        // Turbulent viscosity [K_F] -> (quad,_indx_eqs[K_F]) ---------------------------
        _mu_turb=0.;// eff visc turb at g pt
#ifdef TBK_EQUATIONS
        const int k_idx=_data_eq[2].indx_ub[_data_eq[2].tab_eqs[K_F]];// kappa-equations
        _kappa_g[0]= _ub_g[2][k_idx];
        _kappa_g[1]= _ub_g[2][k_idx+1];
        f_mu(val_tbg);
        kappa_mg[0] +=_kappa_g[0];
        kappa_mg[1] +=_kappa_g[1];
#endif
        double IRe_eff = _IRe*(1.+_mu_turb);//  visc_eff  at g pt
        // ------------------------------------------------------------------------------


        /// d) Assemblying FSI- structural equation
        // iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
        for(int i=0; i< el_ndof[2]; i++) { //  row i loop
          // iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
          // set up row i ---------------------------------------------------------------
          for(int  idim=0; idim<ndim; idim++)  // derivatives row at pt gauss qp
            dphiidx_g[2][idim]=_dphi_g[2][i+idim*el_ndof[2]]; // [2] -> quad only
          const double phii_g=_phi_g[2][i];// shape function (loc row= i) at gaussian pt (qp)

          // iviviviviviviviviviviviviv iviviviviviviviviviviviviv iviviviviviviviviviviv
          for(int  ivar=0; ivar< _nvars[2]; ivar++)  { // i-variable loop
            // iviviviviviviviviviviviviv iviviviviviviviviviviviviv iviviviviviviviviviviv

            int  indx=i+ivar*el_ndof[2];                        // local row index;
            int  indx_uvw=i+(ivar+_dir)*el_ndof[2];             // local coupled dof index;
            int idimp1=(ivar+1+_dir)%ndim;        // block +1  ---------------
            int idimp2=(ivar+2+_dir)%ndim;        // only 3D block +2  ---------------
            double dtxJxW_g=JxW_g[2]*(_bc_vol[i+ivar*NDOF_FEM]%2);// dv jac

#ifndef COMPRESSIBLE
            _lambda=0;
#endif
            double quad_term=0.; // quadratic term --------------------------------------
//          quad_term=Compute_quad_term(_ub_dxg, ivar, _mus,dphiidx_g, _dir, ndim, I,J);
//          if (fabs(quad_term)>10000)  std::cout<<"LAAAAAAArge"<<std::endl;
            // Assemblying rhs ---------------------------------------------------------
            if(mode == 1)                {
              FeM(indx) += dtxJxW_g*(
                             rho*(1/GAMMA)*(vel_g[ivar+_dir]*phii_g/_dt)  // time
//                             +(1-GAMMA)*(vel_g[ivar+_dir]-vel_gold[ivar+_dir])*phii_g/_dt)
//                             -rho*quad_term
                           + rho*_IFr*_dirg[ivar+_dir]*phii_g  // x-gravity
//                               +((ivar ==0)? 1:0)*1.e+2*phii_g
                             -1.*(sum)*dphiidx_g[2][ivar+_dir]*penalty_s2
                           );
// 	      	#ifdef T_EQUATIONS
// 	                    FeM(indx) += dtxJxW_g* rho*(
// 			      -1.e-3*(Temp_g-T_ref)*(_lambda+2*_mus)*dphiidx_g[2][ivar+_dir]
//                            );
// 	      #endif

            }
            // Assemblying Matrix quad ---------------------------------

            // jjjjjjjjjjjjjjjjjjjjjjjj  column  jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj

            for(int j=0; j<el_ndof[2]; j++) {

              const double phij_g= _phi_g[2][j];  // j-shape function
              double Lap_g=0.,Adv_g=0.,Lap0_g=0.;    // set up

              for(int kdim=0; kdim<ndim; kdim++) {
                dphijdx_g[2][kdim] =_dphi_g[2][j+kdim*el_ndof[2]];
//                 Adv_g +=vel_g[kdim]*dphijdx_g[2][kdim]*phii_g;
                Adv_g +=u_nlg[kdim]/*vel_g[kdim]*/*dphijdx_g[2][kdim]*phii_g;
                Lap_g +=(IRe_eff+f_upwind[kdim]*u_nlg[kdim]*u_nlg[kdim])*
                        (dphijdx_g[2][kdim]*dphiidx_g[2][kdim]);
                Lap0_g +=dphijdx_g[2][kdim]*dphiidx_g[2][kdim];
//                 Div_g +=_ub_dxg[kdim+kdim*ndim];
              }

#ifdef LINEAR_ELASTICITY  // ------------------------------------------------------------
// _lambda=0;
/// Linear tensor
              sig_1_lin[ivar+_dir]=_mus*(dphijdx_g[2][ivar+_dir]*dphiidx_g[2][ivar+_dir]+Lap0_g);
              sig_1_lin[idimp1]   =_mus*(dphijdx_g[2][ivar+_dir]*dphiidx_g[2][idimp1]);

              sig_3_lin[ivar+_dir]=_lambda*dphijdx_g[2][ivar+_dir]*dphiidx_g[2][ivar+_dir];
              sig_3_lin[idimp1]   =_lambda*dphijdx_g[2][idimp1]*dphiidx_g[2][ivar+_dir];
#if DIMENSION==3
              int idimp2=(ivar+2+_dir)%ndim;
              sig_1_lin[idimp2]   =_mus*(dphijdx_g[2][ivar+_dir]*dphiidx_g[2][idimp2]);
              sig_3_lin[idimp2]   =_lambda*dphijdx_g[2][idimp2]*dphiidx_g[2][ivar+_dir];
#endif
#ifdef AXISYM     // axysimmetry
              Lap_g +=(1-ivar+_dir)*IRe_eff*phii_g*phij_g/(_ub_g[2][0]*_ub_g[2][0]);
              sig_3_lin[ivar+_dir] +=_lambda*(1-ivar-_dir)*(dphijdx_g[2][ivar+_dir]*phii_g+
                                     dphiidx_g[2][ivar+_dir]*phij_g+phij_g*phii_g/_ub_g[2][0])/_ub_g[2][0];
              sig_3_lin[idimp1]    +=_lambda*(1-ivar-_dir)*(phij_g*dphiidx_g[2][ivar+_dir])/_ub_g[2][0]+
                                     _lambda*(ivar+_dir)*(phii_g*dphijdx_g[2][ivar+_dir])/_ub_g[2][0];
#endif
#endif //LINEAR_ELASTICITY end ----------------------------------------------------------
              // KeM (NS) | 1  2  3 | |u|   FeM (NS)  |u|
              //          | 4  5  6 | |v|             |v|
              //          | 6  7  8 | |v|             |w|
              // diagonal blocks [1-5-9
#if FSI_EQUATIONS%2==0
              if(j<el_ndofp) FeM(indx)+= dtxJxW_g*(p_proj[j]+1.*dp_proj[j])*_phi_g[1][j]*dphiidx_g[2][ivar+_dir]*proj_s;
#endif
              KeM(indx,j+ivar*el_ndof[2]) +=dtxJxW_g*(
                                              (rho+damping)* (1/GAMMA)*phij_g*phii_g/_dt  // time
                                              + Adv_g            // advection
                                              +_dt*(sig_1_lin[ivar+_dir]+sig_3_lin[ivar+_dir]) //Lap_g  viscous Laplacian
// //                                                +val_matp[j+(ivar+_dir)*el_ndof[2]]*dphiidx_g[2][ivar+_dir]
                                              +impl_pen_s*penalty_s2
                                              *dphijdx_g[2][ivar]*dphiidx_g[2][ivar+_dir]
                                              *_mus*_dt
                                            );
              FeM(indx) +=dtxJxW_g*rho*(
                            -1.*(sig_1_lin[ivar+_dir]+sig_3_lin[ivar+_dir])
                          )* ds_old[j+(ivar+_dir)*el_ndof[2]];
//                           _data_eq[2].ub[(sdx_idx+ivar+_dir)*NDOF_FEM+j];

#if FSI_EQUATIONS==2    // splitting
              FeM(indx) += -1.*u_nl[j+idimp1*el_ndof[2]]*
#else       // no splitting
              KeM(indx,j+idimp1*el_ndof[2]) +=
#endif
                           dtxJxW_g* rho*(
                             _dt* (sig_1_lin[idimp1]+sig_3_lin[idimp1])
//                                                +val_matp[j+idimp1*el_ndof[2]]*dphiidx_g[2][ivar+_dir]
                             +impl_pen_s*penalty_s2
                             *dphijdx_g[2][idimp1]*dphiidx_g[2][ivar+_dir]
                             *_mus*_dt
                           );
              FeM(indx) +=
//               -_data_eq[2].ub[(sdx_idx+idimp1)*NDOF_FEM+j]*
                -1.*ds_old[j+idimp1*el_ndof[2]]*
                dtxJxW_g* rho*(sig_1_lin[idimp1]+sig_3_lin[idimp1]
                              );
#if DIMENSION==3
//                          int idimp2=(ivar+2+_dir)%ndim; // block +2 [3-4-8] ------------
#if FSI_EQUATIONS==2    // splitting
              FeM(indx)+=  -1.*u_nl[j+idimp2*el_ndof[2]]*
#else        // no splitting
              KeM(indx,j+idimp2*el_ndof[2])+=
#endif
                           dtxJxW_g* rho*(
                             _dt*(  sig_1_lin[idimp2] +sig_3_lin[idimp2])
//                              +val_matp[j+idimp2*el_ndof[2]]*dphiidx_g[2][ivar+_dir]
                             +impl_pen_s*penalty_s2
                             *dphijdx_g[2][idimp2]*dphiidx_g[2][ivar+_dir]
                             *_mus*_dt
                           );
              FeM(indx) +=
//               -_data_eq[2].ub[(sdx_idx+idimp1)*NDOF_FEM+j]*
                -1.*ds_old[j+idimp2*el_ndof[2]]*
                dtxJxW_g* rho*(sig_1_lin[idimp2]+sig_3_lin[idimp2]
                              );
#endif                // ----------------------------------------------------------------------
            } // end A element matrix quad -quad (end loop on j)---------------------------------------------

            // ------------------------------------------------------------------
#ifndef COMPRESSIBLE
#if FSI_EQUATIONS==1      // B^T element matrix ( p*div(v) )--------------------
            for(int  ikl=0; ikl<2; ikl++) {   // ikl=0 discontinuous ikl=1 continuous pressure
              for(int  ivarl=0; ivarl<_nvars[ikl]; ivarl++) {
                for(int  j=0; j<el_ndof[ikl]; j++) {
                  double psij_g=_phi_g[ikl][j];
                  KeM(indx,j+ndim*el_ndof[2]) +=dtxJxW_g*(  // MPascal
                                                  -psij_g*dphiidx_g[2][ivar]
#ifdef AXISYM
                                                  -(1-ivar)*psij_g*phii_g/_ub_g[2][0]
#endif
                                                );
                } // j
              } // ivarl
            }
#endif  // end B^T element matrix ------------------------------------
#endif
          } // end loop ivar
        } // end loop i

// ------------------    QL    -------------------------------------------------------------------------------------------------------------------

#if FSI_EQUATIONS==1   // only coupled Assemblying Matrix linear ---------------------------------
        for(int  ikl=0; ikl<2; ikl++) {   // ikl=0 discontinuous ikl=1 continuous pressure
          for(int   ivarl=0; ivarl< _nvars[ikl]; ivarl++) {
            for(int   i=0; i< el_ndof[ikl]; i++) {  // +++++++++++
              // set up row i
              int  indx=i+el_ndof[2]*_nvars[2];//ivar=0;
              const double psii_g=_phi_g[ikl][i];
#ifndef COMPRESSIBLE        //(incompressible)
// //                            if (mode == 1)   FeM(indx)  +=  JxW_g[2]*psii_g*_ub_g[1][0]*KOMP_FSI; //    _u_old[DIMENSION]*KOMP_NS;
#endif
#ifdef COMPRESSIBLE
              if(_bc_vol[i+_nvars[2]*NDOF_FEM]<3.5)
                KeM(indx,indx)  =10.;
#endif
#ifndef COMPRESSIBLE
              // linear-quadratic Assemblying Matrix -----------------------------
              for(int j=0; j<el_ndof[2]; j++)     {
                const double phij_g= _phi_g[2][j];
                for(int  jvar=0; jvar< _nvars[2]; jvar++) {  // linear -quad
                  // p-equation
//                                KeM(indx,indx)=1;
//                                 FeM(indx)=0.;
                  KeM(indx,j+jvar*el_ndof[2]) += JxW_g[2]*rho*(
                                                   psii_g*_dphi_g[2][j+jvar*el_ndof[2]]  // div=0
#ifdef AXISYM
                                                   +(1-jvar)*psii_g*phij_g/_ub_g[2][0]
#endif
                                                 );
                }// jvar
              }  // j end linear-quad --------------------------------------------
#endif

//                        linear-linear Assemblying Matrix ------------------------------
//          FeM(i+el_ndof[2]*_nvars[2]) +=JxW_g[2]*psii_g;
//               for(int j=0; j<el_ndof[1]; j++)  {
//                double Lap=0.;
//             for(int idim=0; idim< ndim; idim++) {
//               dphijdx_g[1][idim]=_dphi_g[1][j+idim*_el_dof[1]];
//               Lap +=dphijdx_g[1][idim]*dphiidx_g[1][idim];            // Laplacian
//             }
//             KeM(i+el_ndof[2]*_nvars[2],j+ndim*el_ndof[2])  += JxW_g[2]*Lap;//+psii_g*psij_g;
//                 const double psij_g=_phi_g[1][j];
//           KeM(i+el_ndof[2]*_nvars[2],j+ndim*el_ndof[2])  += JxW_g[2]*psii_g*psij_g*KOMP_NS;

//               } // end linear liner --------------------------------------------
            }  // i
          }// ivarl end linear +++++++++++
        }
#endif  // ------------------------------------------------------------------------------------------------

      } // end of the quadrature point qp-loop

      kappa_mg[0] /=el_ngauss;
      kappa_mg[1] /=el_ngauss;
      mu_m /=el_ngauss;

      // ====================== end solid volume (element) =======================================



      // ======================================================================
      // =========================  solid boundary  =================================
      // ======================================================================
      for(int  iside=0; iside< el_sides; iside++) {
        if(el_neigh[iside] == -1) {

          // local matrix and rhs
//         double IRe_eff=_IRe;

          double pressure[NDOF_FEMB];
          // setup boundary element -> connectivity+coordinates
          for(int  lbnode=0; lbnode<NDOF_FEMB; lbnode++) {
            int lnode=_mgmesh._GeomEl._surf_top[lbnode+NDOF_FEMB*iside];// local nodes
            sur_toply[lbnode]=lnode;          // lbnode -> lnode
            elb_conn[lbnode]=el_conn[lnode];  // connctivity el_conn->elb_conn

            for(int idim=0; idim<ndim; idim++)   // coordinates
              xxb_qnds[idim*NDOF_FEMB+lbnode]=xx_qnds[idim*NDOF_FEM+lnode];

            pressure[lbnode]=_data_eq[1].ub[lnode];
          }

          // normal
          _fe[2]->normal_g(xxb_qnds,normal);

          int dir_neu[DIMENSION]; int bd_flag[DIMENSION];
          for(int ivar=0; ivar< _nvars[2]; ivar++)    {
            dir_neu[ivar]=0;
            bd_flag[ivar]=1;
            for(int  lbnode=0; lbnode<NDOF_FEMB; lbnode++) {
              if(_bc_vol[sur_toply[ lbnode]+ivar*NDOF_FEM]%2 !=0) dir_neu[ivar]=1;
              if(_bc_bd[sur_toply[ lbnode]+ivar*NDOF_FEM] ==0) bd_flag[ivar]=0;
            }
          }

          // pressure flag
//         int flag_p=0;
//         for(int  k=0; k< elb_ndof[1]; k++) { flag_p += _bc_bd[sur_toply[k]+DIMENSION*NDOF_FEM];}

          for(int ivar=0; ivar< _nvars[2]; ivar++)    {



            // Dirichlet boundary conditions  ***********************
            if(dir_neu[ivar]==0) {//;
//                        if (  _bc_vol[sur_toply[NDOF_FEMB-1]+ivar*NDOF_FEM] ==0 ) {

//             int bc_s=(int)_bc_bd[sur_toply[NDOF_FEMB-1]+ivar*NDOF_FEM];     // b cond
              double det= _fe[2]->JacSur(elb_ngauss-1,xxb_qnds, InvJac[2]);              // jacobian
              double Ipenalty=det/_dt;                        // Dirichlet bc flag

              for(int i=0; i< elb_ndof[2]; i++) {  // +++++++++++++++++++++++

                const int  indx_sol=sur_toply[i]+(ivar+_dir)*el_ndof[2];//ivar=0;
                const int  indx_row=sur_toply[i]+(ivar)*el_ndof[2];//ivar=0;


                // bc_normal*(u \dot n)+bc_tg*(u-(u.n)n)=
                //   bc_rhs*[bc_normal*(val \dot n)+bc_tg*(val-(val.n)n)]
                int bc_s=(int)_bc_bd[indx_row]; //int bc_v=(int)_bc_vol[indx_row];
                int bc_rhs=((bc_s&4)>>2);  // (1??) nonhomogeneous
                int bc_tg=((bc_s&2)>>1);   // (?1?) tg
                int bc_normal=(bc_s%2);    // (??1) normal

                double vdotn=0.;  // non-homogeneous normal
//                             for (int kdim=0; kdim<_nvars[2]; kdim++) {
//                                 const int kdof_top = _node_dof[_NoLevels-1][elb_conn[i]+kdim*offset];
//                                 vel_g[kdim] =(*x_old[_NoLevels-1])(kdof_top);
//                                 vdotn +=normal[kdim]*vel_g[kdim];
//                             }
                // Assemblying rhs // non-homogeneous ----------------------------
                if(mode == 1)  {
                  for(int idim=0; idim<_nvars[2]; idim++) bc_value[idim]=0.;


                  FeM(indx_row) += /*bc_rhs*Ipenalty* */
                    (1-bc_rhs)*Ipenalty*(1-bc_normal)*(1-bc_tg)*0.+// bc_value[ivar]+
                    bc_rhs*Ipenalty*( // Dirichlet -> non-homogeneous flag (1??)
                      (1-bc_normal)*(1-bc_tg)*_data_eq[2].ub[ns_idx*NDOF_FEM+indx_sol]// _u_old[indx_sol]    // (100) single comp bc
//                       (1-bc_normal)*(1-bc_tg)*_data_eq[2].ub[ns_idx*NDOF_FEM+indx_sol]// _u_old[indx_sol]    //
                      +bc_normal*vdotn*normal[ivar+_dir]              // (101)normal Dirichlet bc
//                                         +bc_tg*(vel_g[ivar+_dir]-vdotn*normal[ivar+_dir])// (110) tg Dirichlet bc
                    );
                }

                // Assemblying Matrix ---------------------------------
                // u.n normale tg -(u.n)n
                KeM(indx_row,indx_row) +=
                  ((1-bc_normal)*(1-bc_tg)+bc_tg)*Ipenalty // (?00) single comp bc
                  +Ipenalty*normal[ivar+_dir]*normal[ivar+_dir]*(
                    bc_normal   // (?01) Normal Dirichlet bc
                    -1.*bc_tg       // (?10) tg Dirichlet bc
                  );

//                 for(int   jvar=ivar+_dir+1; jvar< ndim+_dir; jvar++)    {
//                   int      jvar1=jvar%DIMENSION;
// #if FSI_EQUATIONS==2
//                   FeM(indx_row) += -1.*Ipenalty*_data_eq[2].ub[(ns_idx+jvar1)*NDOF_FEM+sur_toply[i]]*
// #else
//                   KeM(indx_row,sur_toply[i]+jvar1*el_ndof[2]) += Ipenalty*
// #endif
//                                    normal[jvar1]*normal[ivar+_dir]*(
//                                      +bc_normal   // (?01) Normal Dirichlet bc
//                                      -bc_tg       // (?10) tg Dirichlet bc
//                                    );
//                 }// end  +u.n normale tg -(u.n)n

              }// i loop
            } // end if  Dirichlet  ***********************************

            //  Neumann boundary conditions  ***********************************
//                     else if (_bc_bd[sur_toply[NDOF_FEMB-1]+ivar*NDOF_FEM] !=0) {
            else if(bd_flag[ivar] !=0) {
              double alpha_t=1.;
#ifdef TBK_EQUATIONS
              double kappa_w=kappa_mg[0]+1.e-20;
              double yplus=rho*0.547722557505*_y_dist*sqrt(kappa_w)/(_IRe);
              double u_plus=(yplus< 11.66) ? yplus:2.5*log(9.*yplus);
//              u_plus= yplus;
              alpha_t=rho*0.547722557505*sqrt(kappa_w)/u_plus;
              alpha_t=_IRe/_y_dist;
//          printf(" \n  yplus %f, kappa %12.10f, distance %f, alpha_t %f ",yplus,kappa_w,_y_dist,alpha_t);
//          std::cout << " \n  yplus "<<  yplus << " kappa " << kappa_w << " y " << _y_dist<< " alpha_t " << alpha_t;
#endif

              for(int  qp=0; qp<  elb_ngauss; qp++) {  //gaussian integration loop (n_gauss)

                // quad/linear  [2]=quad [1]=linear------------------------------------
                det[2]     = _fe[2]->JacSur(qp,xxb_qnds, InvJac[2]);   // local coord _phi_g and jac
                JxW_g[2]=det[2]*_fe[2]->_weight1[ndim-2][qp]; // weight
                _fe[2]->get_phi_gl_g(ndim-1,qp,_phi_g[2]);   // global coord _phi_g
                _fe[1]->get_phi_gl_g(ndim-1,qp,_phi_g[1]);   // global coord _phi_g


                interp_el_sol(pressure,0,1,_phi_g[1],elb_ndof[1],_ub_g[1]);

#ifdef AXISYM   // axisymmetric  (index ->0)
                interp_el_sol(_data_eq[2].ub,0,DIMENSION,_phi_g[2],elb_ndof[2],_ub_g[2]);
                JxW_g[2]  *=_ub_g[2][0];
#endif
                // ***********************************
                for(int i=0; i< elb_ndof[2]; i++) {  // Assemblying NS equation
                  // set up row i
                  const double phii_g=_phi_g[2][i];
                  const int   indx_var=sur_toply[i]+(ivar+_dir)*el_ndof[2];// volume dof index
                  const int   indx_row=sur_toply[i]+(ivar)*el_ndof[2];// volume dof index
                  int idimp1=(ivar+1+_dir)%ndim; // block +1 [2-6-7] ---------------

                  const int   indx_row_idimp1=sur_toply[i]+(idimp1+_dir)*el_ndof[2];// volume dof index
#if DIMENSION==3
                  int idimp2=(ivar+2+_dir)%ndim; // block +1 [2-6-7] ---------------
                  const int   indx_row_idimp2=sur_toply[i]+(idimp2+_dir)*el_ndof[2];// volume dof index
#endif

                  // boundary flag
                  int bc_s=(int)_bc_bd[indx_row];
                  int inverter=((bc_s>0)? 1:-1);
                  bc_s=bc_s*inverter;
                  int bc_v=(int)_bc_vol[indx_row];
                  double dtJxW_g=JxW_g[2]*(bc_v%2);
                  int bc_rhs   =((bc_s&4)>>2); // (1??) -> nonhomogeneous
                  int bc_tg    =((bc_s&2)>>1); // (?1?) -> tg
                  int bc_normal=(bc_s%2);      // (??1) -> normal

                  // Assemblying rhs ----------------------------
                  if(mode == 1)   {
//                                   double p_val=inverter*(19650.0583/2);
                    double p_val=inverter*(-100.0);
                    if(imesh==1)
//                                         FeM(indx_row)  += -1.*bc_rhs*dtJxW_g*phii_g*(normal[ivar+_dir])*(_ub_g[1][0]);
                      FeM(indx_row)  += -1.*bc_rhs*dtJxW_g*phii_g*(normal[ivar+_dir])*((p_val)/1.);//(_ub_g[1][0]);
//                                          FeM(indx_row_idimp1)  += -1.*bc_rhs*dtJxW_g*phii_g*(normal[idimp1+_dir])*((p_val)/_refvalue[DIMENSION]);//(_ub_g[1][0]);
#if DIMENSION==3
//   FeM(indx_row_idimp2)  += -1.*bc_rhs*dtJxW_g*phii_g*(normal[idimp2+_dir])*((p_val)/_refvalue[DIMENSION]);//(_ub_g[1][0]);
#endif
                  }

// // //                                 Assemblying Matrix ---------------------------------
                  for(int j=0; j<elb_ndof[2]; j++) {  // quad -quad
                    const double phij_g= _phi_g[2][j];
                    KeM(indx_row,indx_row) +=dtJxW_g*bc_tg*alpha_t*phij_g*phii_g// (?1?) -> tg
                                             + dtJxW_g*alpha_t*normal[ivar+_dir]*normal[ivar+_dir]*phij_g*phii_g*(
                                               bc_normal // (??1) -> normal
                                               -bc_tg     // (?1?) -> tg
                                             );

                    for(int  jvar=ivar+_dir+1; jvar< ndim+_dir; jvar++)    {  // u.n normale tg -(u.n)n
                      int jvar1=jvar%DIMENSION;
#if FSI_EQUATIONS==2
                      FeM(indx_row) +=   -_data_eq[2].ub[ns_idx*NDOF_FEM+sur_toply[j]+jvar1*el_ndof[2]]*
#else
                      KeM(indx_row,sur_toply[j]+jvar1*el_ndof[2]) +=
#endif
                                         dtJxW_g*alpha_t*normal[jvar1]*normal[ivar+_dir]*phij_g*phii_g*(
                                           +bc_normal   // (?01) Normal Dirichlet bc
                                           -bc_tg       // (?10) tg Dirichlet bc
                                         );
                    }

                  }//  j-loop
                }// i-loop

              }// end gaussian  integration



            }  //  end if Neumann  ***********************************

          } // end if ivar   +++++++++++++++++++++++++++++++


        } //end if side
      } //end for iside

      // ==========================================================================
      // ====================== end solid boundary =====================================
      // ==========================================================================
    }//end phase ==1








    /// e) Add them to the global matrix ------------------------
    A[Level]->add_matrix(KeM,el_dof_indices);
    if(mode == 1) b[Level]->add_vector(FeM,el_dof_indices);


//   if(iel==0) {
//    cout << KeM << endl;
//   }

  } // end of element loop
  // clean ---------------------------------------------------


  el_dof_indices.clear();
  A[Level]->close();
  if(mode == 1) b[Level]->close();
  A[Level]->print();

  // ----------------------------------------------------------
#ifdef PRINT_INFO
  std::cout << " GenMatRhs(FSI): Assembled  " << Level << " (Level) "  << std::endl;
#endif

  return;
}
// =========================================================================================
/// This function controls the assembly and the solution of the NS_equation system:
void MGSolFSI::MGTimeStep(
  const double time,  // time
  const int /*iter*/  // Number of max inter
)
{
// =========================================================================================

/// A) Set up the time step
  std::cout  << std::endl << "  " << _eqname.c_str() << " solution "  << std::endl;
  x[_NoLevels-1]->localize(*x_nonl[_NoLevels-1]);

  /// B) Assemblying of the Matrix-Rhs
#if PRINT_TIME==1
  std::clock_t start_time=std::clock();
#endif
  GenMatRhs(time,_NoLevels-1,1);                                                // matrix and rhs
  for(int Level = 0 ; Level < _NoLevels-1; Level++) GenMatRhs(time,Level,0);  // matrix
#if PRINT_TIME==1
  std::clock_t end_time=std::clock();
  std::cout << "  Assembly time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC << " s "<< std::endl;
#endif

//   / C) Solution of the linear MGsystem (MGSolFSI::MGSolve).
  MGSolve(1.e-6,40);
  x[_NoLevels-1]->localize(*x_nonl[_NoLevels-1]);
#if PRINT_TIME==1
  end_time=std::clock();
  std::cout << " Assembly+solution time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC
            << "s "<< std::endl;
#endif

  /// D) Update of the old solution at the top Level  (MGSolFSI::OldSol_update),

// #if FSI_EQUATIONS%2==0

//     disp[_NoLevels-1]->zero();
//     x_oold[_NoLevels-1]->close();
//    x_oold[_NoLevels-1]->zero();





  double norm_diff=1.;
  for(int iter=0; iter<NNL_ITER; iter++) {

    x[_NoLevels-1]->localize(*x_nonl[_NoLevels-1]);
//      x_nonl[_NoLevels-1]->zero();
//
    double norm_in= x_nonl[_NoLevels-1]->l2_norm();
    std::cout <<" norm xnl*********** " << norm_in  << std::endl;
// // //     aaaaaaaaaaaaaa
 #if FSI_EQUATIONS==0
    x_oold[_NoLevels-1]->add(1.e+4,*x_nonl[_NoLevels-1]); // penalty
#endif
    std::cout <<" norm x_oold--------- " <<  x_oold[_NoLevels-1]->l2_norm()  << std::endl;
    // non linear solution
    std::cout  << std::endl << " === NON LINEAR ITERATOR: "<< iter+1 << "- " << _eqname.c_str() << " solution "  << std::endl;
//
//     A[_NoLevels-1]->close();
    GenMatRhs(time,_NoLevels-1,1);                                                // matrix and rhs
    for(int Level = 0 ; Level < _NoLevels-1; Level++)   GenMatRhs(time,Level,0);  // matrix
    MGSolve(1.e-6,40);                                                            // solve

    // check error
    x[_NoLevels-1]->localize(*disp[_NoLevels-1]);
    disp[_NoLevels-1]->add(-1.e+0,*x_nonl[_NoLevels-1]);
    norm_diff=  disp[_NoLevels-1]->l2_norm();
    std::cout << " Check:  "<< " norm_in "<< norm_in <<
              "  norm_diff/-norm_in " <<norm_diff/norm_in <<std::endl
              <<" === END NON LINEAR ITERATOR"<<std::endl;
    if(norm_diff/norm_in<1.e-3) break;

  }


// #endif
  x[_NoLevels-1]->localize(*x_old[_NoLevels-1]);

#if FSI_EQUATIONS%2==0
  /// E) mesh update
//   x_oold[_NoLevels-1]->add(1.,(*x_old[_NoLevels-1]));
#endif
  return;
}// =======================================================================================



// =========================================================================================
/// This function controls the assembly and the solution of the NS_equation system:
void MGSolFSI::MGTimeStep_nl_setup(
  const double time,  // time
  const int /*iter*/  // Number of max inter
)
{
// =========================================================================================




/// A) Set up the time step
  std::cout  << std::endl << "  " << _eqname.c_str() << " MGTimeStep_nl_setup "  << std::endl;
  x[_NoLevels-1]->localize(*x_nonl[_NoLevels-1]);
//   x_oold[_NoLevels-1]->zero();
  /// B) Assemblying of the Matrix-Rhs
#if PRINT_TIME==1
  std::clock_t start_time=std::clock();
#endif
  GenMatRhs(time,_NoLevels-1,1);                                                // matrix and rhs
  for(int Level = 0 ; Level < _NoLevels-1; Level++)   GenMatRhs(time,Level,0);  // matrix
#if PRINT_TIME==1
  std::clock_t end_time=std::clock();
  std::cout << "  Assembly time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC << " s "<< std::endl;
#endif

//   / C) Solution of the linear MGsystem (MGSolFSI::MGSolve).
  MGSolve(1.e-6,40);
#if PRINT_TIME==1
  end_time=std::clock();
  std::cout << " Assembly+solution time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC
            << "s "<< std::endl;
#endif

  /// D) Update of the old solution at the top Level  (MGSolFSI::OldSol_update),

// #if FSI_EQUATIONS%2==0

//     disp[_NoLevels-1]->zero();
//     x_oold[_NoLevels-1]->close();
//    x_oold[_NoLevels-1]->zero();




















// // /// A) Set up the time step
//   std::cout  << std::endl << "  " << _eqname.c_str() << " solution "  << std::endl;

//   /// B) Assemblying of the Matrix-Rhs
// #if PRINT_TIME==1
//   std::clock_t start_time=std::clock();
// #endif
//   GenMatRhs(time,_NoLevels-1,1);                                                // matrix and rhs
//   for(int Level = 0 ; Level < _NoLevels-1; Level++)   GenMatRhs(time,Level,0);  // matrix
// #if PRINT_TIME==1
//   std::clock_t end_time=std::clock();
//   std::cout << "  Assembly time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC << " s "<< std::endl;
// #endif
//
// //   / C) Solution of the linear MGsystem (MGSolFSI::MGSolve).
//   MGSolve(1.e-6,40);
// #if PRINT_TIME==1
//   end_time=std::clock();
//   std::cout << " Assembly+solution time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC
//             << "s "<< std::endl;
// #endif
//
//
// #if FSI_EQUATIONS%2==0
// //    disp[_NoLevels-1]->zero();
//   x[_NoLevels-1]->localize(*x_nonl[_NoLevels-1]);
//   /// E) mesh update
//    x_oold[_NoLevels-1]->add(1.,(*x_nonl[_NoLevels-1]));
// //   x_oold[_NoLevels-1]->close();
// //   x_oold[_NoLevels-1]->zero();
// #endif
  _norm_in=1;
  _norm_out=2;

  return;
}// =======================================================================================
// =========================================================================================
/// This function controls the assembly and the solution of the NS_equation system:
void MGSolFSI::MGTimeStep_nl_sol_up(
  const double time,  // time
  const int /*iter*/  // Number of max inter
)
{
// =========================================================================================
  /// D) Update of the old solution at the top Level  (MGSolFSI::OldSol_update),
  std::cout  << std::endl << "  " << _eqname.c_str() << " MGTimeStep_nl_sol_up "  << std::endl;
  x[_NoLevels-1]->localize(*x_old[_NoLevels-1]);

  // penalty --------------------------------------------------------------------------------
// #if FSI_EQUATIONS%2==0
//   /// E) mesh update
//    x_oold[_NoLevels-1]->add(1.,(*x_old[_NoLevels-1]));
// //   const int n_nodes=_mgmesh._NoNodes[_NoLevels-1];
// //   const int offsetp=_dir*n_nodes;
// //   for(int idim=0; idim<_nvars[2]; idim++)
// //     for(int inode=0; inode<n_nodes; inode++) {
// //       x_oold[_NoLevels-1]->add(inode+idim*n_nodes,((*x_old[_NoLevels-1])(inode+idim*n_nodes)));
// //     }
// //    EquationSystemsExtendedM *ext_es=dynamic_cast<EquationSystemsExtendedM *>(&_mgeqnmap);
// #endif


  return;
}// =======================================================================================
/// ======================================================
/// This function controls the time step operations:
/// ======================================================
int MGSolFSI::MGTimeStep_nl_iter(const double time, int)
{

  int itest=0;




  double norm_diff=1.;
//   for(int iter=0; iter<20; iter++) {

  x[_NoLevels-1]->localize(*x_nonl[_NoLevels-1]);
  x_nonl[_NoLevels-1]->close();
  double norm_in= x_nonl[_NoLevels-1]->l2_norm();

  std::cout <<" norm xnl*********** " << norm_in  << std::endl;
//     x_oold[_NoLevels-1]->close();
//     x_oold[_NoLevels-1]->zero();
#if FSI_EQUATIONS%2==0
  x_oold[_NoLevels-1]->add(1.e+6,*x_nonl[_NoLevels-1]); // penalty
#endif
//     x_oold[_NoLevels-1]->close();
//     x[_NoLevels-1]->close();
//     b[_NoLevels-1]->close();
  A[_NoLevels-1]->close();
//    std::cout <<" norm x_oold--------- " <<  x_oold[_NoLevels-1]->l2_norm()  << std::endl;
  // non linear solution
//     std::cout  << std::endl << " === NON LINEAR ITERATOR: "<< iter+1 << "- " << _eqname.c_str() << " solution "  << std::endl;
  GenMatRhs(time,_NoLevels-1,1);                                                // matrix and rhs
  for(int Level = 0 ; Level < _NoLevels-1; Level++)   GenMatRhs(time,Level,0);  // matrix
  MGSolve(1.e-6,40);                                                            // solve

  // check error
  x[_NoLevels-1]->localize(*disp[_NoLevels-1]);
  disp[_NoLevels-1]->add(-1.e+0,*x_nonl[_NoLevels-1]);
  norm_diff=  disp[_NoLevels-1]->l2_norm();
  std::cout << " Check:  "<< " norm_in "<< norm_in <<
            "  norm_diff/-norm_in " <<norm_diff/norm_in <<std::endl
            <<" === END NON LINEAR ITERATOR"<<std::endl;
  if(norm_diff/norm_in<1.e-3) itest=1;

//   }



#if FSI_EQUATIONS%2==0
  /// E) mesh update
//   x_oold[_NoLevels-1]->add(1.,(*x_old[_NoLevels-1]));
#endif



















// #if FSI_EQUATIONS%2==0
//
//
//
//   std::cout  << std::endl << "  " << _eqname.c_str() << " solution "  << std::endl;
//
//
//
// //   for(int iterator=0; iterator<8; iterator++) {
//
// //     x[_NoLevels-1]->localize(*disp[_NoLevels-1]);
// //   x[_NoLevels-1]->localize(*x_nonl[_NoLevels-1]);
//   _norm_out= x_nonl[_NoLevels-1]->l2_norm();
//   std::cout << " norm_in  "<< _norm_in<< " norm_out  "<< _norm_out<<std::endl;
//
//
//
// //   if(fabs(_norm_in-_norm_out)/_norm_in>1.e-8) {
// //       std::cout << " ============= NON LINEAR ITERATOR============  "<< iterator<<std::endl;
//   #if FSI_EQUATIONS%2==0
//   /// E) mesh update
//    x_oold[_NoLevels-1]->add(1.,(*x_nonl[_NoLevels-1]));
// #endif


// // //   const int n_nodes=_mgmesh._NoNodes[_NoLevels-1];
// // //   const int offsetp=_dir*n_nodes;
// // //   for(int idim=0; idim<_nvars[2]; idim++)
// // //     for(int inode=0; inode<n_nodes; inode++) {
// // // //        double ss=(*x_oold[_NoLevels-1])(inode)+;
// // // //     x_oold[_NoLevels-1]->add(inode,(1000*_dt*(*x_old[_NoLevels-1])(inode)));
// // //       x_oold[_NoLevels-1]->add(0.e+0,*x_nonl[_NoLevels-1]);
// // //     }
// //   GenMatRhs(time,_NoLevels-1,1);                                                // matrix and rhs
// //   for(int Level = 0 ; Level < _NoLevels-1; Level++)   GenMatRhs(time,Level,0);  // matrix
// //   MGSolve(1.e-6,40);
// //   _norm_in=_norm_out;
// //   x[_NoLevels-1]->localize(*x_nonl[_NoLevels-1]);
// // //   } else { itest=1;}





  return itest;
// #endif
}



#ifdef TBK_EQUATIONS
// =====================================================
void  MGSolFSI::f_mu(double val[])
{
  // Turbulent viscosity
  if(_kappa_g[0]< 1.e-20) _kappa_g[0]= 1.e-20;  // kappa
  if(_kappa_g[1]< 1.e-20) _kappa_g[1]= 1.e-20;  // epsilon/omega
  double tau_k=1.;  // turbulent time

#if (TBK_EQUATIONS==0)   //kappa  (Prandtl length)--------------------------
  tau_k=_y_dist/sqrt(_kappa_g[0]);
#endif  // end kappa -------------------------------------------------------

#if (TBK_EQUATIONS/2==1)  // kappa-epsilon (TBK_EQUATIONS=2 or 3) ---------- 
  tau_k= CMU*_kappa_g[0]/_kappa_g[1]; // tau=1/omega=CMU*kappa/epsilon
#endif   // kappa-epsilon --------------------------------------------------

#if (TBK_EQUATIONS/2==2)       // kappa-omega ------------------------------
  tau_k=1/_kappa_g[1]; // tau=1/omega

#endif  // -----------------------------------------------------------------
  if(tau_k> MAX_TAU) tau_k= MAX_TAU;
// turbulent viscosity
  double Re_t= _kappa_g[0]*tau_k/_IRe;
  // limits
  if(Re_t > MU_TOP)  Re_t =MU_TOP;
  if(Re_t < MU_LOW)  Re_t =MU_LOW;

  _mu_turb=Re_t;

//     // Boundary corrections
//    double R_t=Re_t/CMU;                                             // turbulent Reynolds number
//    double R_eps =_y_dist*sqrt(_kappa_g[0]/sqrt(R_t))/_IRe;
//    double f_mu =(1.-exp(-1.*R_eps/(14.)))*(1.-exp(-1.*R_eps/14.));
//    _mu_turb *=f_mu*(1.+5./pow(R_t,0.75)*exp(-1.*R_t*R_t/40000.));    // correction

// #ifdef LOWRE     /// B) Low-Reynolds  correction model
//     const double alpha_star=1.*(0.024+ 0.166666666667*Re_t)/(1.+0.166666666667*Re_t);
//     _mu_turb *=alpha_star;

// #endif


#ifdef SST

  // F1 and F2 coeff calculation
  double F1,F2;
  double F1_first  = 500.*_IRe*tau_k/(_y_dist*_y_dist);
  double F2_first= 2.*sqrt(_kappa_g[0])*tau_k/(BETASTAR*_y_dist);
  if(F1_first > F2_first) F2_first=F1_first;
  F2=tanh(F2_first*F2_first);

  // nu_t calculation
//       double alpha_star        = 1.;//(0.024+ Re_t/6.)/(1.+ Re_t/6.);
  double alpha_starb = sqrt(_sP)*F2*tau_k/0.31;
  if(alpha_starb < 1.) {
    alpha_starb=1.; /*printf("alpha star is %f and and %f and %f\n",alpha_starb, 1./tau_k, F2);*/
  }
  _mu_turb /= alpha_starb;

// _mu_turb = Re_t;
  if(_mu_turb > MU_TOP)  _mu_turb =MU_TOP; ub_g[1][1]
  if(_mu_turb < MU_LOW)  _mu_turb =MU_LOW;
//       printf("mu_turb is %f \n",_mu_turb);

#endif

  return;
}

#endif

// #if (FSI_EQUATIONS%2==0)
// ===============================================================
// --------------   PRESSURE EQUATION [P_F] ------------------
// ===============================================================
// ==============================================================
// FSI_EQUATIONS==0 projection solver (u,v,w) ( P in NSP_EQUATIONS)
// FSI_EQUATIONS==1 coupled    solver (u,v,w,p)
// FSI_EQUATIONS==2 segregated solver (u,v,w) ( P in NSP_EQUATIONS)
// ===============================================================



// ==================================================================
/// This function constructs the 3d-2D MGSolFSIP class I
MGSolFSIP::MGSolFSIP(
  MGEquationsSystem& mg_equations_map_in,
  int             nvars_in[],    ///
  std::string     eqname_in,    ///< name equation (in)
  std::string     varname_in    ///< name variable (in)
):  MGSolDA(mg_equations_map_in,nvars_in,eqname_in,varname_in),
  /// A) reading parameters
  _offset(_mgmesh._NoNodes[_NoLevels-1]), // mesh nodes (top level)
  _dt(_mgutils.get_par("dt")),            // parameter  dt
  _uref(mg_equations_map_in.get_par("Uref")),         // parameter  u reference
  _lref(mg_equations_map_in.get_par("Lref")),         // parameter  l reference
  _rhof(mg_equations_map_in.get_par("rho0")),         // parameter density
  _muf(mg_equations_map_in.get_par("mu0"))
{
  // parameter viscosity
//  ===========================================
  /// B) setting class variables
  _var_names[0]="p";  _refvalue[0]=_rhof*_uref*_uref;    // class variable names

  /// C ) setting solver type
  for(int  l=0; l<_NoLevels; l++)  _solver[l]->set_solver_type(SOLVER_FSI);

  /// D) setting nondimensional parameters
  return;
}//  ================================================================





//  ====================================================
/// This function assembles the matrix and the rhs:
//  ====================================================
void  MGSolFSIP::GenMatRhs(
  const double /* time*/, // time  <-
  const int  Level,  // Level <-
  const  int mode    // mode  <- (1=rhs) (0=only matrix)
)    // ===============================================
{

  ///A) Set up
  // geometry ---------------------------------------------------------------------------------------
  const int   ndim = DIMENSION;                      //dimension
  const int   offset = _mgmesh._NoNodes[_NoLevels-1];// mesh nodes
  double      xx_qnds[DIMENSION*NDOF_FEM];           // element node coords
//   int         el_conn[NDOF_FEM];                    // element connectivity
  const int  el_sides= _mgmesh._GeomEl._n_sides[0];                      // element nodes
  int        el_conn[NDOF_FEM], elb_conn[NDOF_FEMB];                     // element connectivity
  int        el_neigh[NDOF_FEM];                                         // element connectivity
  // gauss integration  ------------------------------------------------------------------------------
  double det[3],JxW_g[3],InvJac[3][DIMENSION*DIMENSION];           // Jac, Jac*w Jacobean
  double dphijdx_g[3][DIMENSION];  double dphiidx_g[3][DIMENSION]; // global derivatives at g point
  const int  el_ngauss = _fe[2]->_NoGauss1[ndim-1];                //elem gauss points
  double u_nl[DIMENSION*NDOF_FEM];  double u_old[DIMENSION*NDOF_FEM];
  // element dofs: costant[0]-linear[1]-quadratic[2]-------------------------------------------------
  int el_ndof[3];  el_ndof[0]=1;                  // number of el dofs
  int el_mat_nrows =0;                            // number of mat rows (dofs)
  for(int ideg=1; ideg<3; ideg++) {
    el_ndof[ideg]=_fe[ideg]->_NoShape[ndim-1];
    el_mat_nrows +=_nvars[ideg]*el_ndof[ideg];
  };
  int el_mat_ncols = el_mat_nrows;                     //square matrix
  std::vector<int > el_dof_indices(el_mat_ncols);      // element dof vector

  //  fields -> Navier-Stokes  [NS_F]
  int ns_idx=_data_eq[2].indx_ub[_data_eq[2].tab_eqs[FS_F]];

  // element matrix and rhs  (mode 0= matrix only or mode 1=matrix +rhs) ---------------------------
  A[Level]->zero();                       if(mode ==1) b[Level]->zero();   // global matrix+rhs
  DenseMatrixM KeM;                       DenseVectorM FeM;                // local  matrix+rhs
  KeM.resize(el_mat_nrows,el_mat_ncols);  FeM.resize(el_mat_nrows);        // resize  local  matrix+rhs


  int ndof_lev=0;
  for(int pr=0; pr <_mgmesh._iproc; pr++) {
    int delta =_mgmesh._off_el[0][pr*_NoLevels+Level+1]-_mgmesh._off_el[0][pr*_NoLevels+Level];
    ndof_lev +=delta;
  }

  const int  nel_e = _mgmesh._off_el[0][Level+_NoLevels*_iproc+1]; // start element
  const int  nel_b = _mgmesh._off_el[0][Level+_NoLevels*_iproc];   // stop element
  for(int iel=0; iel < (nel_e - nel_b); iel++) {

    ///B) Element  Loop over the volume (n_elem)
    // set to zero matrix and rhs and center
    KeM.zero();         FeM.zero();

    // geometry and element  fields ------------------------------------
    // Element Connectivity (el_conn)  and coordinates (xx_qnds)
// // //     _mgmesh.get_el_nod_conn(0,Level,iel,el_conn,xx_qnds);oldddd
    _mgmesh.get_el_nod_conn(0,Level,iel,el_conn,xx_qnds);
    _mgmesh.get_el_neighbor(el_sides,0,Level,iel,el_neigh);
    // local system fields
//     get_el_dof_bc(Level,el_ndof,el_conn,offset,el_dof_indices,_bc_vol,_bc_bd);old

    get_el_dof_bc(Level,iel+ndof_lev,_el_dof,el_conn,offset,el_dof_indices,_bc_vol,_bc_bd);

    // element nodes coordinates
    for(int  d=0; d< NDOF_FEM; d++)
      for(int  idim=0; idim<DIMENSION; idim++)
        _data_eq[2].ub[idim*NDOF_FEM+d]=xx_qnds[idim*NDOF_FEM+d];

    // external fields
//     for(int deg=0; deg<3; deg++) {
//       for(int eq=0; eq<_data_eq[deg].n_eqs; eq++) {
//         _data_eq[deg].mg_eqs[eq]->get_el_sol(0,_data_eq[deg].indx_ub[eq+1]-_data_eq[deg].indx_ub[eq],
//                                              el_ndof[deg],el_conn,offset,_data_eq[deg].indx_ub[eq],_data_eq[deg].ub);
//       }
//     }

#if FSI_EQUATIONS==2 //
    for(int idim=0; idim<DIMENSION; idim++) {
      _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F+idim]]->get_el_nonl_sol(0,1,el_ndof[2],el_conn, offset,idim,u_nl);
      _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F+idim]]->get_el_sol(0,1,el_ndof[2],el_conn, offset,idim,u_old);
    }
#endif
#if FSI_EQUATIONS==0
    _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F]]->get_el_nonl_sol(0,DIMENSION,el_ndof[2],el_conn, offset,0,u_nl);
    _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F]]->get_el_sol(0,DIMENSION,el_ndof[2],el_conn, offset,0,u_old);
#endif

    /// c) gaussian integration loop (n_gauss)
    for(int  qp=0; qp< el_ngauss; qp++) {  // +++++++++++++++++++++++++++++++++


      // shape functions at gaussian points -----------------------------------
      for(int  ideg=1; ideg<3; ideg++) {  // linear-quadratic  [1]=linear [2]=quad
        det[ideg]      = _fe[ideg]->Jac(qp,xx_qnds,InvJac[ideg]);     // Jacobian
        JxW_g[ideg] =det[ideg]*_fe[ideg]->_weight1[ndim-1][qp];       // weight
        _fe[ideg]->get_phi_gl_g(ndim,qp,_phi_g[ideg]);               // shape funct
        _fe[ideg]->get_dphi_gl_g(ndim,qp,InvJac[ideg],_dphi_g[ideg]); // global coord deriv
      }
#if FSI_EQUATIONS==2
      double uvw_dxg[DIMENSION];
      for(int kdim=0; kdim<DIMENSION; kdim++) {
        interp_el_gdx(_data_eq[2].ub,ns_idx+kdim,1,_dphi_g[2],el_ndof[2],uvw_dxg);
        for(int jdim=0; jdim<DIMENSION; jdim++) _ub_dxg[jdim+kdim*DIMENSION]=uvw_dxg[jdim];
      }
#else
      //external fields (quad only)
      interp_el_gdx(_data_eq[2].ub,ns_idx,DIMENSION,_dphi_g[2],el_ndof[2],_ub_dxg);
#endif
      /// d) Local (element) assemblying pressure equation
      for(int  i=0; i<el_ndof[1]; i++)     {
        // set up row i if(xp[1]<0.01) {
//         u_value[1] =4.;
//         if(xp[0] >LXB*ILref+BDRY_TOLL && xp[0] <LXE*ILref-BDRY_TOLL) {  u_value[0] =.1; }
        const double phii_g=_phi_g[1][i];
        double Div_g=0.;
        for(int  idim=0; idim< ndim; idim++)  {
          dphiidx_g[1][idim]=_dphi_g[1][i+idim*el_ndof[1]];
//           Div_g +=_ub_dxg[idim+idim*DIMENSION];      //divergence of velocity field
        }
        double dtxJxW_g=JxW_g[2]*_bc_vol[i];

        // Rhs Assemblying  ----------------------------
//         if(mode == 1)  FeM(i) += -1.*dtxJxW_g*Div_g*phii_g/_dt;
        for(int  j=0; j<el_ndof[2]; j++) {
          for(int  idim=0; idim< ndim; idim++) {
            dphijdx_g[2][idim]=_dphi_g[2][j+idim*el_ndof[2]];
            FeM(i) += -1.*dtxJxW_g*(u_old[NDOF_FEM*idim+j])* dphijdx_g[2][idim]*phii_g/(_dt);
//              FeM(i) += -1.*dtxJxW_g*phii_g;
          }
        }

        // Matrix Assemblying ---------------------------
        for(int  j=0; j<el_ndof[1]; j++) {
          double Lap=0.;

          for(int  idim=0; idim< ndim; idim++) {
            dphijdx_g[1][idim]=_dphi_g[1][j+idim*el_ndof[1]];
            Lap += dphijdx_g[1][idim]*dphiidx_g[1][idim]; // Laplacian
          }

          // pressure matrix assembling
          KeM(i,i) += JxW_g[2]*(1-_bc_vol[i]);
//           if(_bc_bd[i]==1) FeM(i)+=JxW_g[2]*(0)*(1-_bc_vol[i]);
//           if(_bc_bd[i]==2) FeM(i)+=JxW_g[2]*(0)*(1-_bc_vol[i]);
          KeM(i,j) += dtxJxW_g*Lap*_bc_vol[j];
        } // ---------------------------------------------
      }
    } // end of the quadrature point qp-loop +++++++++++++++++++++++++

    /// e) Global assemblying pressure equation
    A[Level]->add_matrix(KeM,el_dof_indices);                  // global matrix
    if(mode == 1)   b[Level]->add_vector(FeM,el_dof_indices);  // global rhs

  } // end of element loop
  // clean and close
  el_dof_indices.clear();
  A[Level]->close();    if(mode == 1)  b[Level]->close();

#ifdef PRINT_INFO
  std::cout<< " Matrix Assembled(P)  for  Level "<< Level << " dofs " << A[Level]->n() <<"\n";
#endif

  return;
}

// =========================================================================================
/// This function controls the assembly and the solution of the P_equation system:
void MGSolFSIP::MGTimeStep(
  const double time,  // time
  const int /*iter*/  // Number of max inter
)
{
// =========================================================================================

/// A) Set up the time step
  std::cout  << std::endl << "  " << _eqname.c_str() << " solution "  << std::endl;

  /// B) Assemblying of the Matrix-Rhs
#if PRINT_TIME==1
  std::clock_t start_time=std::clock();
#endif
  GenMatRhs(time,_NoLevels-1,1);                                                // matrix and rhs
  for(int Level = 0 ; Level < _NoLevels-1; Level++)  GenMatRhs(time,Level,0);  // matrix
#if PRINT_TIME==1
  std::clock_t end_time=std::clock();
  std::cout << "  Assembly time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC << " s "<< std::endl;
#endif

  /// C) Solution of the linear MGsystem (MGSolP::MGSolve).
  MGSolve(1.e-6,50);
#if PRINT_TIME==1
  end_time=std::clock();
  std::cout << " Assembly+solution time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC
            << "s "<< std::endl;
#endif

  /// D) Update of the old solution at the top Level  (MGSolP::OldSol_update),
  x[_NoLevels-1]->localize(*x_oold[_NoLevels-1]);  // dp
//   double a=1.;
//   if(time >0.) a=.01;
  x_old[_NoLevels-1]->add(1.,*x_oold[_NoLevels-1]);// p

  return;
}// =======================================================================================

// =========================================================================================
/// This function controls the assembly and the solution of the P_equation system:
void MGSolFSIP::MGTimeStep_nl_setup(
  const double time,  // time
  const int /*iter*/  // Number of max inter
)
{
// =========================================================================================

  return;
}// =======================================================================================
// =========================================================================================
/// This function controls the assembly and the solution of the P_equation system:
void MGSolFSIP::MGTimeStep_nl_sol_up(
  const double time,  // time
  const int /*iter*/  // Number of max inter
)
{
  /// A) Set up the time step
  std::cout  << std::endl << "  " << _eqname.c_str() << " solution "  << std::endl;

  /// B) Assemblying of the Matrix-Rhs
#if PRINT_TIME==1
  std::clock_t start_time=std::clock();
#endif
  GenMatRhs(time,_NoLevels-1,1);                                                // matrix and rhs
  for(int Level = 0 ; Level < _NoLevels-1; Level++)  GenMatRhs(time,Level,0);  // matrix
#if PRINT_TIME==1
  std::clock_t end_time=std::clock();
  std::cout << "  Assembly time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC << " s "<< std::endl;
#endif

  /// C) Solution of the linear MGsystem (MGSolP::MGSolve).
  MGSolve(1.e-6,50);
#if PRINT_TIME==1
  end_time=std::clock();
  std::cout << " Assembly+solution time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC
            << "s "<< std::endl;
#endif

  /// D) Update of the old solution at the top Level  (MGSolP::OldSol_update),
  x[_NoLevels-1]->localize(*x_oold[_NoLevels-1]);  // dp
//   double a=1.;
//   if(time >0.) a=.01;
  x_old[_NoLevels-1]->add(1.,*x_oold[_NoLevels-1]);// p



  return;
}// =======================================================================================
/// ======================================================
/// This function controls the time step operations:
/// ======================================================
int MGSolFSIP::MGTimeStep_nl_iter(const double time, int)
{

  return 0;
}
// #endif // ENDIF FSI_EQUATIONS==0
#endif  //ENDIF FSI_EQUATIONS
// #endif  // NS_equation is personal
