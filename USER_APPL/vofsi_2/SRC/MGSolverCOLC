#include "Equations_conf.h"
// ============================================
#ifdef COLOR_EQUATIONS // 3D-2D Energy equation
// ============================================

#include "MGSolverCOL.h"
// #include "MGSFSIconf.h"

// config file -------------------------------------------------
#include "MGFE_conf.h"        // FEM approximation
#include "MGGeomEl.h"        // FEM approximation
#include "Printinfo_conf.h"  // Print options

// local Femus class include -----------------------------------
// #include "MGMesh.h"          // Mesh class
#include "MeshExtended.h"
#include "MGFE.h"          // Mesh class
#include "MGSystem.h"        // System class
#include "MGEquationsSystem.h"  // Equation map class
#include "EquationSystemsExtendedM.h"  // Equation map class

// standard lib -----------------------------------------------
#include <string.h>          // string library

// local alg lib -----------------------------------------------
#include "dense_matrixM.h"   // algebra dense matrices
#include "sparse_matrixM.h"  // algebra sparse matrices
#include "dense_vectorM.h"   // algebra dense vectors
#include "numeric_vectorM.h" // algebra numerical vectors
#include "linear_solverM.h"  // algebra solvers
// ==============================================================
#ifdef HAVE_MED
#include "MEDCouplingUMesh.hxx"
#include "MEDCouplingFieldDouble.hxx"
#include "MEDLoader.hxx"
#include "InterfaceFunctionM.h"
#endif



// ======================================================
/// This function constructs the 3d-2D MGSolCOLX_Y_Z class 
MGSolCOL::MGSolCOL(MGEquationsSystem& mg_equations_map_in,
		       const int vars_in[],
                       std::string eqname_in,
                       std::string varname_in):
    MGSolDA(mg_equations_map_in,vars_in,eqname_in,varname_in),
    // mesh params ------------
    _offset(_mgmesh._NoNodes[_NoLevels-1]), // mesh nodes
    // phys params ------------
    _dt(_mgutils.get_par("dt")),       // parameter  dt
    _rhof(mg_equations_map_in.get_par("rho0")),    // parameter  density reference
    _uref(mg_equations_map_in.get_par("Uref")),    // parameter  vel reference
    _lref(mg_equations_map_in.get_par("Lref")),    // parameter  length reference
    _Tref(mg_equations_map_in.get_par("Tref")),    // parameter  temperature reference
    _rhos(mg_equations_map_in.get_par("rhos"))     // parameter solid density
{ //  =================================================
  // class variable names
  _dir=0;
  _var_names[0]="div";     _refvalue[0]=_lref;
   _var_names[1]=varname_in;  
  for (int l=0;l<NDOF_FEM;l++) {_bc_vol[l]=-1; _bc_bd[l]=-1;}
  
  // class solver type (SOLVERT  in MGSTconf.h)
//   for (int l=0;l<_NoLevels;l++) _solver[l]->set_solver_type(CGM);
     for (int l=0;l<_NoLevels;l++) _solver[l]->set_solver_type(GMRESM);
    
  return;
}


//  ====================================================
/// This function assembles the matrix and the rhs:
//  ====================================================
void  MGSolCOL::GenMatRhs(
  const double /* time*/, // time  <-
  const int Level,  // Level <-
  const  int mode    // mode  <- (1=rhs) (0=only matrix)
) {  // ===============================================
///A) Set up
  // geometry ---------------------------------------------------------------------------------------

  /// Set up
  // geometry and bc---------------------------------------------------------------------------------
  const int ndim = DIMENSION;                         // dimension
  const int offset = _mgmesh._NoNodes[_NoLevels-1];   // mesh nodes
  const int el_sides= _mgmesh._GeomEl._n_sides[0];    // element sides
  int       el_conn[NDOF_FEM];// elb_conn[NDOF_FEMB];   // element connectivity
  int       el_neigh[NDOF_FEM];                       // bd element connectivity
  int       elb_conn[NDOF_FEMB];// elb_conn[NDOF_FEMB];   // element connectivity
  int       sur_toply[NDOF_FEMB];                     // boundary topology
  double    xx_qnds[DIMENSION*NDOF_FEM];              // element node coords
  double    xxb_qnds[DIMENSION*NDOF_FEMB];            // boundary of the element node coords
  int       _bc_vol[NDOF_FEM*10];                // element  b.cond flags (Neu or Dir)
  int       _bc_bd[NDOF_FEM*10];                 // element  b.cond flags (different possibilities)

  // gauss integration  -----------------------------------------------------------------------------
  const int el_ngauss = _fe[2]->_NoGauss1[ndim-1];         // quadratic element gauss points
  const int elb_ngauss = _fe[2]->_NoGauss1[DIMENSION-2];   // quadratic bd elem gauss points
  double det[3],JxW_g[3],InvJac[3][DIMENSION*DIMENSION];   // determinant of Jacobean and det*gauss_weigth
  double dphijdx_g[3][DIMENSION];                          // global derivatives at gauss point
  double dphiidx_g[3][DIMENSION];                          // global derivatives at gauss point
  double _dt =0.1;
double u_old[DIMENSION*NDOF_FEM];double divu_old[NDOF_FEM];
  double ds_old[DIMENSION*NDOF_FEM];
  // element dofs (costant[0]-linear[1]-quadratic[2]) -----------------------------------------------
  int elb_ndof[3];
  elb_ndof[0]=NDOF_BK; elb_ndof[1]=NDOF_PB; elb_ndof[2]=NDOF_FEMB;  // number of element boundary dofs
  int el_mat_nrows =0;                                              // number of matrix rows (dofs)
  for(int ideg=0; ideg<3; ideg++) el_mat_nrows +=_nvars[ideg]*_el_dof[ideg];
  int el_mat_ncols = el_mat_nrows;                    // square matrix
  std::vector<int> el_dof_indices(el_mat_ncols);      // element dof vector

    int el_ndof[3];  el_ndof[0]=1;                  // number of el dofs
//   int el_mat_nrows =0;                            // number of mat rows (dofs)
  for(int ideg=1; ideg<3; ideg++) {
    el_ndof[ideg]=_fe[ideg]->_NoShape[ndim-1];
//     el_mat_nrows +=_nvars[ideg]*el_ndof[ideg];
  };
  
  
  // coupling  fields -------------------------------------------------------------------------------
  int fsi_idx=_data_eq[2].indx_ub[_data_eq[2].tab_eqs[FS_F]]; // Quadratic
  double _ub_g[3][14];                                     // values of external fields

  // element matrix and rhs  (mode 0= matrix only or mode 1=matrix+rhs) ---------------------------
  A[Level]->zero(); if(mode ==1) b[Level]->zero();                 // global matrix A and rhs b
  DenseMatrixM KeM; DenseVectorM FeM;                              // local  matrix KeM and rhs FeM
  KeM.resize(el_mat_nrows,el_mat_ncols); FeM.resize(el_mat_nrows); // resize local matrix and rhs

  // number of total elements for level
  int ndof_lev=0;
  for(int pr=0; pr <_mgmesh._iproc; pr++) {
    int delta =_mgmesh._off_el[0][pr*_NoLevels+Level+1]-_mgmesh._off_el[0][pr*_NoLevels+Level];
    ndof_lev +=delta;
  }
  // test pass
// #ifdef HAVE_COUPLING
//     MGSystemExtended * ext_es= static_cast<MGSystemExtended *>(&_mgphys);
//      double test_pass= ext_es->_nComp;
// #endif


  /// b) Element  Loop over the volume (n_elem)
  const int nel_e = _mgmesh._off_el[0][Level+_NoLevels*_iproc+1]; // start element
  const int nel_b = _mgmesh._off_el[0][Level+_NoLevels*_iproc];   // stop element

  for(int iel=0; iel < (nel_e - nel_b); iel++) {
  for(int i=0; i <NDOF_FEM; i++) divu_old[i]=0;
    KeM.zero(); FeM.zero();      // set to zero matrix and rhs

    // geometry and element  fields ------------------------------------

    _mgmesh.get_el_nod_conn(0,Level,iel,el_conn,xx_qnds);   // Element Connectivity (el_conn) and coordinates (xx_qnds)
    _mgmesh.get_el_neighbor(el_sides,0,Level,iel,el_neigh); // Neighbors of the element

    // set element-nodes variables  bc (bc_q_dofs)
    get_el_dof_bc(Level,iel+ndof_lev,_el_dof,el_conn,offset,el_dof_indices,_bc_vol,_bc_bd);
    double phase=0;
      for(int  i=0; i<NDOF_FEM; i++)  {
     if (_bc_vol[i]> 1.5 &&  _bc_vol[i]< 3.5){phase =1;}
  }

    // grid and gaussian points
    for(int idim=0; idim<DIMENSION; idim++) {
      for(int d=0; d< NDOF_FEM; d++) _data_eq[2].ub[idim*NDOF_FEM+d]=xx_qnds[idim*NDOF_FEM+d];  // element nodes xxg (DIM)
      // element grid distance
    }
    // element field values
//         for (int deg=0; deg<3; deg++) {
    for(int eq=0; eq<_data_eq[2].n_eqs; eq++) {
      _data_eq[2].mg_eqs[eq]->get_el_sol(0,_data_eq[2].indx_ub[eq+1]-_data_eq[2].indx_ub[eq],
                                         _el_dof[2],el_conn,offset,_data_eq[2].indx_ub[eq],_data_eq[2].ub);
    }
//         }
    //linear field
    _data_eq[1].mg_eqs[0]->get_el_sol(_nvars[2],_data_eq[1].indx_ub[0],_el_dof[1],el_conn,offset,0,_data_eq[1].ub);
    //  external node quantities -------------------------------------

    _data_eq[0].mg_eqs[0]->get_el_sol_piece(_nvars[2]+_nvars[1],_data_eq[0].indx_ub[0],_el_dof[0],iel+ndof_lev,offset,0,_data_eq[0].ub);
    
    
#if FSI_EQUATIONS==2 //
    for(int idim=0; idim<DIMENSION; idim++){
//       _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F+idim]]->get_el_nonl_sol(0,1,el_ndof[2],el_conn, offset,idim,u_nl);
      _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F+idim]]->get_el_sol(0,1,el_ndof[2],el_conn, offset,idim,u_old);
    }
#endif
#if FSI_EQUATIONS==0
//     _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F]]->get_el_nonl_sol(0,DIMENSION,el_ndof[2],el_conn, offset,0,u_nl);
    _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F]]->get_el_sol(0,DIMENSION,el_ndof[2],el_conn, offset,0,u_old);
    
#endif
    
#if FSI_EQUATIONS==1
//     _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F]]->get_el_nonl_sol(0,DIMENSION,el_ndof[2],el_conn, offset,0,u_nl);
    _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[FS_F]]->get_el_sol(0,DIMENSION,el_ndof[2],el_conn, offset,0,u_old);
#endif 
    
#ifdef DS_EQUATIONS  
          for(int kdim=0; kdim<ndim; kdim++){
     _data_eq[2].mg_eqs[_data_eq[2].tab_eqs[SDSX_F+kdim]]->
                           get_el_sol(0,1,el_ndof[2],el_conn, offset,kdim,ds_old);
      }
#endif
    // ======================================================================
    // Volume =============================================================
    // ======================================================================
    // ---------------------------------------------
    /// c) gaussian integration loop (n_gauss)
    // --------------------------------------------
    for(int qp=0; qp< el_ngauss; qp++) {

      // shape functions at gaussian points -----------------------------------
      for(int ideg=1; ideg<3; ideg++) {  // linear-quadratic  [1]=linear [2]=quad
        det[ideg]      = _fe[ideg]->Jac(qp,xx_qnds,InvJac[ideg]);     // Jacobian
        JxW_g[ideg] =det[ideg]*_fe[ideg]->_weight1[ndim-1][qp];       // weight
        _fe[ideg]->get_phi_gl_g(ndim,qp,_phi_g[ideg]);               // shape funct
        _fe[ideg]->get_dphi_gl_g(ndim,qp,InvJac[ideg],_dphi_g[ideg]); // global coord deriv
      }

      JxW_g[0]=JxW_g[2];
      _fe[0]->get_phi_gl_g(ndim,qp,_phi_g[0]);               // shape function piecewise


      //  fields -----------------------------------------------------------
      interp_el_sol(_data_eq[2].ub,0,_data_eq[2].indx_ub[_data_eq[2].n_eqs],
                    _phi_g[2],_el_dof[2],_ub_g[2]); // quadratic
      interp_el_sol(_data_eq[1].ub,0,_data_eq[1].indx_ub[0],_phi_g[1],_el_dof[1],_ub_g[1]); // linear
      interp_el_sol(_data_eq[0].ub,0,_data_eq[0].indx_ub[0],_phi_g[0],_el_dof[0],_ub_g[0]); //constant


      /// d) Local (element) assemblying DA equation
      // *********************** *******************************

      for(int i=0; i<_el_dof[2]; i++)     {    //  --- QUADRATIC ---
        // set up row i
        const double phii_g=_phi_g[2][i];
        for(int idim=0; idim< ndim; idim++)  dphiidx_g[2][idim]=_dphi_g[2][i+idim*_el_dof[2]];
//         int gl_node=el_conn[i];

        for(int ivar=0; ivar<_nvars[2]; ivar++) {

          double dtxJxW_g=JxW_g[2]*(_bc_vol[i+ivar*_el_dof[2]]%2);
          int index=i+ivar*_el_dof[2];

          // Rhs Assemblying  ----------------------------------------------------------
          if(mode == 1) {

            // rhs
	            for(int  j=0; j<el_ndof[2]; j++) {
          for(int  idim=0; idim< ndim; idim++) {
            dphijdx_g[2][idim]=_dphi_g[2][j+idim*el_ndof[2]];
// 	    double result=(u_old[NDOF_FEM*idim+j]*dphijdx_g[2][idim]);// divergence
	    double result=(ds_old[NDOF_FEM*1+j]*dphijdx_g[2][1])/ndim;// dsydy
             FeM(i) +=dtxJxW_g*result;
	     divu_old[j]+=result;
// 	     *dphijdx_g[2][idim]
// 	     *phii_g
	     ;
          
          }
           
        }
   KeM(i,i) =dtxJxW_g*(1.);
//             FeM(index) += dtxJxW_g*(
// //                             _ub_g[2][DA_f+ivar]*phii_g/_dt   // time
//                             +0.*phii_g                      // heat source
//                           );
          }

          // Matrix Assemblying ---------------------------
//           for(int j=0; j<_el_dof[2]; j++) {
//             double phij_g= _phi_g[2][j];
//             double Lap=0.;
//             for(int idim=0; idim< ndim; idim++) {
//               dphijdx_g[2][idim]=_dphi_g[2][j+idim*_el_dof[2]];
//               Lap +=dphijdx_g[2][idim]*dphiidx_g[2][idim];            // Laplacian
//             }
// 
//             // energy-equation
//             KeM(index,j+ivar*_el_dof[2]) +=dtxJxW_g*(
// 	                                       phii_g*phij_g
// //                                              phii_g*phij_g/_dt // time term
// //                                              + Lap                   //diff
//                                            );
//           }
        } // quadratic variable cycle
      } // ----------------------------------------END QUADRATIC




      for(int i=0; i<_el_dof[0]; i++)     {  //    --- Piecewise ---
        // set up row i
        const double phii_g=_phi_g[0][i];
        for(int ivar=0; ivar<_nvars[0]; ivar++) {

          double dtxJxW_g=JxW_g[0]*_bc_vol[i+(ivar+_nvars[1]+_nvars[2])*NDOF_FEM];
          int index=i+ivar*_el_dof[0]+_el_dof[2]*_nvars[2]+_el_dof[1]*_nvars[1];

          // Rhs Assemblying  ----------------------------------------------------------
          if(mode == 1) {
            // rhs
            FeM(index) = dtxJxW_g*(phase
// 			                  _ub_g[2][0]*phii_g
//                             _ub_g[0][ivar]*phii_g/_dt   // time
//                             +_data_eq[2].ub[0]*phii_g*(1-ivar)         //source x
//                             +_data_eq[2].ub[0]*_data_eq[2].ub[1]*_data_eq[2].ub[2]*phii_g*ivar   //source x*y*z
                          );
	    
	     KeM(index,index)=dtxJxW_g*(1.);
          }
          // Matrix Assemblying ---------------------------
        } ////  variable cycle
      } // ----------------------------------END piecewise





    } // end of the quadrature point qp-loop ***********************


      for(int iside=0; iside< el_sides; iside++)  {
        if(el_neigh[iside] == -1 && 1==2) {

          for(int idof=0; idof<NDOF_FEMB; idof++) {
            sur_toply[idof]=_mgmesh._GeomEl._surf_top[idof+NDOF_FEMB*iside];// local nodes
            int idofb=sur_toply[idof];
//           elb_conn[idof]=el_conn[idofb];                 // connctivity vector
            for(int idim=0; idim<DIMENSION; idim++) {
              xxb_qnds[idim*NDOF_FEMB+idof]=xx_qnds[idim*NDOF_FEM+idofb]; // coordinates
              _data_eq[2].ub[idim*NDOF_FEM+idof]=xxb_qnds[idim*NDOF_FEMB+idof];
            }
          }

          // Dirichlet boundary conditions  ***********************************
//           if((_bc_vol[sur_toply[NDOF_FEMB-1]]%2) ==0) {

            //[NDOF_FEMB-1] is the midpoint of a quadaratic FEM element (HEX9 (2D) or HEX27 (3D))
            int bc_s=(int)_bc_bd[sur_toply[NDOF_FEMB-1]];     // b cond
            double det= _fe[2]->JacSur(elb_ngauss-1,xxb_qnds,InvJac[2]);// jacobian
            double Ipenalty=det/_dt;                               // Dirichlet bc flag
            // local boundary loop   ---------------------------------------
            for(int lb_node=0; lb_node< elb_ndof[2]; lb_node++) {

              int lv_node= sur_toply[lb_node]; // local vol index
              // flag setup (\int bc_var*T+bc_var*val)
//            int  bc_val = (int)((bc_s&2)>>1);  // (1?)non homogeneous
              int  bc_var = (int)(bc_s%2);       // (?1) variable
              // Assemblying  Matrix & rhs
// 	    if (interface==1 ) std::cout<< "\n "<< _bc_vol[lv_node];
              if(mode == 1) FeM(lv_node) = Ipenalty*(divu_old[lv_node])
// 		(u_old[lv_node])*(u_old[lv_node])
// 		+(u_old[1*NDOF_FEM+lv_node])*(u_old[1*NDOF_FEM+lv_node])
		;
// 	      std::cout<< u_old[lv_node]<<"     "<<(u_old[1*NDOF_FEM+lv_node]) <<std::endl;
              KeM(lv_node,lv_node) = Ipenalty;  //  Dirichlet bc
            }// lb_node -end  local boundary loop -------------------------
//           } // end if Dirichlet  boundary conditions
          // **********************************************************************

        } //end if side
      } // ======================  end for fluid boundary =======================================
   
    /// e) Global assemblying energy equation
    A[Level]->add_matrix(KeM,el_dof_indices);                  // global matrix
    if(mode == 1)   b[Level]->add_vector(FeM,el_dof_indices);  // global rhs
  } // end of element loop
  // clean
  el_dof_indices.clear();
  A[Level]->close();
//     A[Level]->print();
  if(mode == 1) b[Level]->close();
  
  
  
#ifdef PRINT_INFO
  std::cout<< " Matrix Assembled(DA)  for  Level "<< Level << " dofs " << A[Level]->n() <<"\n";
#endif

  return;
}
  

















//  ====================================================
/// This function assembles the matrix and the rhs:
//  ====================================================
void  MGSolCOL::ColorFunc(
  const double /* time*/, // time  <-
  const int Level,  // Level <-
  const  int mode    // mode  <- (1=rhs) (0=only matrix)
) {  // ===============================================

  /// Set up
  // geometry -----
  const int  ndim = DIMENSION;                                           //dimension
  double     xx_qnds[DIMENSION*NDOF_FEM], xxb_qnds[DIMENSION*NDOF_FEMB]; // element node coords
  int        el_conn[NDOF_FEM];//, elb_conn[NDOF_FEMB];                     // element connectivity
  int        el_neigh[NDOF_FEM];                                         // element connectivity
  const int  offset = _mgmesh._NoNodes[_NoLevels-1];                     // mesh nodes
  const int  el_sides= _mgmesh._GeomEl._n_sides[0];                      // element nodes
  int        sur_toply[NDOF_FEMB]; // boundary topology
//   double     vel_g[DIMENSION];  for(int idim=0;idim<DIMENSION;idim++) vel_g[idim] =0.; 
//   double  val_tbg[3];
  int fl_int;
  int phase;
  int interface;
//   int interface;
//   double rho;
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
   // gauss integration  -----------------------------------------------------------------------------
    const int el_ngauss = _fe[2]->_NoGauss1[ndim-1];         // quadratic element gauss points
    const int elb_ngauss = _fe[2]->_NoGauss1[DIMENSION-2];   // quadratic bd elem gauss points
    
    // element dofs (costant[0]-linear[1]-quadratic[2]) -----------------------------------------------
    int elb_ndof[3];
    elb_ndof[0]=NDOF_BK; elb_ndof[1]=NDOF_PB; elb_ndof[2]=NDOF_FEMB;  // number of element boundary dofs 
    int el_mat_nrows =0;                                              // number of matrix rows (dofs)
    for (int ideg=0; ideg<3; ideg++) el_mat_nrows +=_nvars[ideg]*_el_dof[ideg];
    int el_mat_ncols = el_mat_nrows;                    // square matrix
    std::vector<int> el_dof_indices(el_mat_ncols);      // element dof vector

       
    // element matrix and rhs  (mode 0= matrix only or mode 1=matrix+rhs) ---------------------------
    DenseVectorM XeM;
    XeM.resize(el_mat_nrows);
    // number of total elements for level
    int ndof_lev=0;
        for (int pr=0;pr <_mgmesh._iproc; pr++) {
            int delta =_mgmesh._off_el[0][pr*_NoLevels+Level+1]-_mgmesh._off_el[0][pr*_NoLevels+Level];
            ndof_lev +=delta;
        }
        
        
    /// b) Element  Loop over the volume (n_elem)
    const int nel_e = _mgmesh._off_el[0][Level+_NoLevels*_iproc+1]; // start element
    const int nel_b = _mgmesh._off_el[0][Level+_NoLevels*_iproc];   // stop element
    for (int iel=0; iel < (nel_e - nel_b); iel++) {
    
	XeM.zero();     // set to zero matrix and rhs

        // geometry and element  fields ------------------------------------
        
        _mgmesh.get_el_nod_conn(0,Level,iel,el_conn,xx_qnds);   // Element Connectivity (el_conn) and coordinates (xx_qnds)
        _mgmesh.get_el_neighbor(el_sides,0,Level,iel,el_neigh); // Neighbors of the element

        // set element-nodes variables  bc (bc_q_dofs)
        get_el_dof_bc(Level,iel+ndof_lev,_el_dof,el_conn,offset,el_dof_indices,_bc_vol,_bc_bd);

        // ======================================================================
        // Volume =============================================================
        // ======================================================================
for (int n_dof_count =0; n_dof_count< el_mat_nrows; n_dof_count++)
  XeM(n_dof_count)=10.;
 // *********************** *******************************
    phase=(_bc_vol[NDOF_FEM-1]<2)?0:1; 
    for(int i=1;i<el_sides+1;i++)  if(_bc_vol[NDOF_FEM-i] > 4.5 ) interface=1.;
            for (int i=0; i<_el_dof[2]; i++)     {   //  --- QUADRATIC ---
                for (int ivar=0;ivar<_nvars[2];ivar++) {
		   int index=i+ivar*_el_dof[2];
                        XeM(index) = 2.*phase;
		}
	    }
            for (int i=0; i<_el_dof[1]; i++)     { //    --- LINEAR ---
                for (int ivar=0;ivar<_nvars[1];ivar++) {
                    int index=i+ivar*_el_dof[1]+_el_dof[2]*_nvars[2];
                        XeM(index) =2.*phase ;
                    }
	    }
            for (int i=0; i<_el_dof[0]; i++)     { //    --- Piecewise ---
                for (int ivar=0;ivar<_nvars[0];ivar++) {
                    int index=i+ivar*_el_dof[0]+_el_dof[2]*_nvars[2]+_el_dof[1]*_nvars[1];
                        XeM(index) = 1.*phase;
		}
	    }
for (int a=0; a < el_mat_nrows ; a++)
  x[Level]->set(el_dof_indices[a],XeM(a));



  } // end of element loop
  // clean
  el_dof_indices.clear();
#ifdef PRINT_INFO
  std::cout<< " Matrix Assembled(T)  for  Level "<< Level << " dofs " << A[Level]->n() <<"\n";
#endif


  
  return;
}




















// =========================================================================================
/// This function controls the assembly and the solution of the T_equation system:
void MGSolCOL::MGTimeStep(const double time, const int /*iter*/) { // ------------------------------------

// #ifdef AXISYM
// if(_dir==1) return;
// #endif

  std::cout  << std::endl << "  " << _eqname.c_str() << " solution "  << std::endl;
  /// B) Assemblying of the rhs (top level in surface and volume with MGSolNS::GenRhs,GenRhsB),
#if PRINT_TIME==1
  std::clock_t start_time=std::clock();
#endif
//   ColorFunc(time,_NoLevels-1,1);
  GenMatRhs(time,_NoLevels-1,1);
  A[_NoLevels-1]->close();
  /// C) Assemblying of the  MGmatrices (MGSolNS::GenMatrix),
  for(int Level = 0 ; Level < _NoLevels-1; Level++) {
    GenMatRhs(time,Level,0); // matrix
    A[Level]->close();
  }
#if PRINT_TIME==1
  std::clock_t end_time=std::clock();
  std::cout << "  Assembly time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC << " s "<< std::endl;
#endif

  /// E) Solution of the linear MGsystem (MGSolNS::MGSolve).
  MGSolve(1.e-6,5);
#if PRINT_TIME==1
  end_time=std::clock();
  std::cout << " Assembly+solution time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC
            << "s "<< std::endl;
#endif
  /// A) Update of the old solution at the top Level  (MGSolNS::OldSol_update),
//   x[_NoLevels-1]->localize(*x_old[_NoLevels-1]);
 
    //update x_oold
//   x_oold[_NoLevels-1]->zero();
//   x_oold[_NoLevels-1]->add(1,*x_old[_NoLevels-1]); 

//   //update x_old
   x[_NoLevels-1]->localize(*x_old[_NoLevels-1]);
// 
  
//   const int flag_moving_mesh = _mgutils.get_par("moving_mesh");
//   
// //    //update dx_old ========================================
//    if(flag_moving_mesh) {
//     /// E) mesh update    
//    const int n_nodes=_mgmesh._NoNodes[_NoLevels-1];
//    const int offsetp=_dir*n_nodes;
//    for (int inode=0;inode<n_nodes;inode++) { 
//        double disp=(*x_old[_NoLevels-1])(inode)-(*x_oold[_NoLevels-1])(inode);
//       _mgmesh._dxdydz[inode+offsetp] += disp;
//      }
//    }
   // ==============================================================

 return;
}

// =========================================================================================
/// This function controls the assembly and the solution of the T_equation system:
void MGSolCOL::MGTimeStep_nl_setup(const double time, const int /*iter*/) { // ------------------------------------

// #ifdef AXISYM
// if(_dir==1) return;
// #endif

  std::cout  << std::endl << "  " << _eqname.c_str() << " solution "  << std::endl;
  /// B) Assemblying of the rhs (top level in surface and volume with MGSolNS::GenRhs,GenRhsB),
#if PRINT_TIME==1
  std::clock_t start_time=std::clock();
#endif
  ColorFunc(time,_NoLevels-1,1);
//   GenMatRhs(time,_NoLevels-1,1);
//   A[_NoLevels-1]->close();
  /// C) Assemblying of the  MGmatrices (MGSolNS::GenMatrix),
  for(int Level = 0 ; Level < _NoLevels-1; Level++) {
//     GenMatRhs(time,Level,0); // matrix
//     A[Level]->close();
  }
#if PRINT_TIME==1
  std::clock_t end_time=std::clock();
  std::cout << "  Assembly time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC << " s "<< std::endl;
#endif

  /// E) Solution of the linear MGsystem (MGSolNS::MGSolve).
//   MGSolve(1.e-6,40);
#if PRINT_TIME==1
  end_time=std::clock();
  std::cout << " Assembly+solution time -----> ="<< double(end_time- start_time) / CLOCKS_PER_SEC
            << "s "<< std::endl;
#endif
  /// A) Update of the old solution at the top Level  (MGSolNS::OldSol_update),
//   x[_NoLevels-1]->localize(*x_old[_NoLevels-1]);
 
    //update x_oold
//   x_oold[_NoLevels-1]->zero();
//   x_oold[_NoLevels-1]->add(1,*x_old[_NoLevels-1]); 

//   //update x_old
// 
  
//   const int flag_moving_mesh = _mgutils.get_par("moving_mesh");
//   
// //    //update dx_old ========================================
//    if(flag_moving_mesh) {
//     /// E) mesh update    
//    const int n_nodes=_mgmesh._NoNodes[_NoLevels-1];
//    const int offsetp=_dir*n_nodes;
//    for (int inode=0;inode<n_nodes;inode++) { 
//        double disp=(*x_old[_NoLevels-1])(inode)-(*x_oold[_NoLevels-1])(inode);
//       _mgmesh._dxdydz[inode+offsetp] += disp;
//      }
//    }
   // ==============================================================

 return;
}
#endif

